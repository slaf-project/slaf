<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/favicon.ico" />
    <!-- Preload is necessary because we show these images when we disconnect from the server,
    but at that point we cannot load these images from the server -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/gradient-yHQUC_QB.png" as="image" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/noise-60BoTA8O.png" as="image" />
    <!-- Preload the fonts -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/Lora-VariableFont_wght-B2ootaw-.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/PTSans-Regular-CxL0S8W7.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/PTSans-Bold-D9fedIX3.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Regular-BTCkDNvf.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Medium-DU3aDxX5.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Bold-CLVRCuM9.ttf" as="font" crossorigin="anonymous" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="a marimo app" />
    <link rel="apple-touch-icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/apple-touch-icon.png" />
    <link rel="manifest" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/manifest.json" />

    <script data-marimo="true">
      function __resizeIframe(obj) {
        var scrollbarHeight = 20; // Max between windows, mac, and linux

        function setHeight() {
          var element = obj.contentWindow.document.documentElement;
          // If there is no vertical scrollbar, we don't need to resize the iframe
          if (element.scrollHeight === element.clientHeight) {
            return;
          }

          // Create a new height that includes the scrollbar height if it's visible
          var hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
          var newHeight = element.scrollHeight + (hasHorizontalScrollbar ? scrollbarHeight : 0);

          // Only update the height if it's different from the current height
          if (obj.style.height !== `${newHeight}px`) {
            obj.style.height = `${newHeight}px`;
          }
        }

        // Resize the iframe to the height of the content and bottom scrollbar height
        setHeight();

        // Resize the iframe when the content changes
        const resizeObserver = new ResizeObserver((entries) => {
          setHeight();
        });
        resizeObserver.observe(obj.contentWindow.document.body);
      }
    </script>
    <marimo-filename hidden>01-getting-started.py</marimo-filename>
    <title>01-getting-started</title>
    <script type="module" crossorigin crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/index-_Zd2Tjcq.js"></script>
    <link rel="stylesheet" crossorigin crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/index-BVt8Dtzn.css">

<script data-marimo="true">
    window.__MARIMO_STATIC__ = {};
    window.__MARIMO_STATIC__.files = {};
</script>
</head>
  <body>
    <div id="root"></div>
    <script data-marimo="true">
      window.__MARIMO_MOUNT_CONFIG__ = {
            "filename": "01-getting-started.py",
            "mode": "read",
            "version": "0.14.0",
            "serverToken": "static",
            "config": {"completion": {"activate_on_typing": true, "copilot": false}, "display": {"cell_output": "above", "code_editor_font_size": 14, "dataframes": "rich", "default_table_page_size": 10, "default_width": "medium", "theme": "light"}, "formatting": {"line_length": 79}, "keymap": {"overrides": {}, "preset": "default"}, "language_servers": {"pylsp": {"enable_flake8": false, "enable_mypy": true, "enable_pydocstyle": false, "enable_pyflakes": false, "enable_pylint": false, "enable_ruff": true, "enabled": true}}, "package_management": {"manager": "pip"}, "runtime": {"auto_instantiate": true, "auto_reload": "off", "default_sql_output": "auto", "on_cell_change": "autorun", "output_max_bytes": 8000000, "reactive_tests": true, "std_stream_max_bytes": 1000000, "watcher_on_save": "lazy"}, "save": {"autosave": "after_delay", "autosave_delay": 1000, "format_on_save": false}, "server": {"browser": "default", "follow_symlink": false}, "snippets": {"custom_paths": [], "include_default_snippets": true}},
            "configOverrides": {},
            "appConfig": {"sql_output": "auto", "width": "medium"},
            "view": {"showAppCode": true},
            "notebook": {"cells": [{"code": "import marimo as mo\nimport numpy as np\n\nfrom slaf import SLAFArray\nfrom slaf.integrations import scanpy as slaf_scanpy\nfrom slaf.integrations.anndata import read_slaf\n", "code_hash": "20d4e7813f7e3b8e7027c5d90376db59", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Hbol", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n# SLAF Getting Started Guide\n\nThis notebook introduces SLAF (Sparse Lazy Array Format) - a high-performance format for single-cell data that combines the power of SQL with lazy evaluation.\n\n**Key Benefits:**\n\n- \ud83d\ude80 **Fast**: SQL-level performance for data operations\n\n- \ud83d\udcbe **Memory Efficient**: Lazy evaluation, only load what you need\n\n- \ud83d\udd0d **SQL Native**: Direct SQL queries on your data\n\n- \ud83e\uddec **Scanpy Compatible**: Drop-in replacement for AnnData workflows\n\n- \u26a1 **Production Ready**: Built for large-scale single-cell analysis\n\n- \u2699\ufe0f **ML Ready**: Ready for ML training with efficient tokenization\n\"\"\"\n)", "code_hash": "cbc43f7eb0a77091897e6c3ab88eb932", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "MJUe", "name": "_"}, {"code": "# Load SLAF dataset using the low-level interface\nslaf = SLAFArray(\"../slaf-datasets/pbmc3k_processed.slaf\")\nprint(f\"\u2705 Loaded SLAF dataset: {slaf.shape[0]:,} cells \u00d7 {slaf.shape[1]:,} genes\")\n\n# Show dataset information\nslaf.info()", "code_hash": "b972ed512c4117db3c57c302d9fec088", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "vblA", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 1. Understanding the SLAF Database Schema\n\nSLAF stores data in three main tables that you can query directly with SQL:\n\"\"\"\n)", "code_hash": "774279e6925bf51e4933ebd96d6f9462", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "bkHC", "name": "_"}, {"code": "def show_database_schema():\n    # Show the database schema\n    print(\"\ud83d\udcca SLAF Database Schema\")\n    print(\"=\" * 50)\n\n    # Get table information\n    tables = [\"cells\", \"genes\", \"expression\"]\n\n    for table in tables:\n        print(f\"\\n\ud83d\udd0d Table: {table}\")\n        if table == \"cells\":\n            print(\"   Purpose: Cell metadata and QC metrics\")\n            print(\"   Key columns:\")\n            print(\"     - cell_id: Unique cell identifier\")\n            print(\"     - cell_integer_id: Integer ID for efficient queries\")\n            print(\"     - batch: Batch information\")\n            print(\"     - total_counts: Total UMI counts per cell\")\n            print(\"     - n_genes_by_counts: Number of genes expressed\")\n            print(\"     - high_mito: Boolean flag for high mitochondrial content\")\n        elif table == \"genes\":\n            print(\"   Purpose: Gene metadata and annotations\")\n            print(\"   Key columns:\")\n            print(\"     - gene_id: Unique gene identifier\")\n            print(\"     - gene_integer_id: Integer ID for efficient queries\")\n            print(\"     - highly_variable: Boolean flag for highly variable genes\")\n        elif table == \"expression\":\n            print(\"   Purpose: Sparse expression matrix data\")\n            print(\"   Key columns:\")\n            print(\"     - cell_id: Cell identifier (foreign key)\")\n            print(\"     - gene_id: Gene identifier (foreign key)\")\n            print(\"     - cell_integer_id: Integer cell ID for efficient queries\")\n            print(\"     - gene_integer_id: Integer gene ID for efficient queries\")\n            print(\"     - value: Expression value (UMI counts)\")\n\n    return\n\nshow_database_schema()", "code_hash": "a0a0dde4f016fde99dbbecc2adcec0f6", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "lEQa", "name": "_"}, {"code": "def show_sample_data():\n    # Show sample data from each table\n    print(\"\ud83d\udccb Sample Data from Each Table\")\n    print(\"=\" * 50)\n\n    # Sample from cells table\n    print(\"\\n\ud83d\udd2c Sample cells:\")\n    cells_sample = slaf.query(\"SELECT * FROM cells LIMIT 3\")\n    print(cells_sample.to_string(index=False))\n\n    # Sample from genes table\n    print(\"\\n\ud83e\uddec Sample genes:\")\n    genes_sample = slaf.query(\"SELECT * FROM genes LIMIT 3\")\n    print(genes_sample.to_string(index=False))\n\n    # Sample from expression table\n    print(\"\\n\ud83d\udcc8 Sample expression data:\")\n    expr_sample = slaf.query(\"SELECT * FROM expression LIMIT 5\")\n    print(expr_sample.to_string(index=False))\n\nshow_sample_data()", "code_hash": "6bd63b5cd8660f224e3b27cd6f3d0470", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "PKri", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 2. SQL Queries - Your Data, Your Way\n\nSLAF gives you direct SQL access to your data. Here are some practical examples:\n\"\"\"\n)", "code_hash": "dc72ee1631e56f8b726513287b28a2de", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Xref", "name": "_"}, {"code": "def run_basic_sql_queries():\n    # Basic SQL queries\n    print(\"\ud83d\udd0d Basic SQL Queries\")\n    print(\"=\" * 40)\n\n    # Count records\n    print(\"\\n1. Count records in each table:\")\n    for table in [\"cells\", \"genes\", \"expression\"]:\n        count = slaf.query(f\"SELECT COUNT(*) as count FROM {table}\")\n        print(f\"   {table}: {count.iloc[0]['count']:,} records\")\n\n    # Batch distribution\n    print(\"\\n2. Batch distribution:\")\n    batch_distribution = slaf.query(\n        \"\"\"\n        SELECT batch, COUNT(*) as count\n        FROM cells\n        GROUP BY batch\n        ORDER BY count DESC\n    \"\"\"\n    )\n    print(batch_distribution.to_string(index=False))\n\n    # Expression statistics\n    print(\"\\n3. Expression value statistics:\")\n    expr_stats = slaf.query(\n        \"\"\"\n        SELECT\n            MIN(value) as min_expr,\n            MAX(value) as max_expr,\n            AVG(value) as avg_expr,\n            COUNT(*) as total_records,\n            COUNT(CASE WHEN value > 0 THEN 1 END) as non_zero_records\n        FROM expression\n    \"\"\"\n    )\n    print(expr_stats.to_string(index=False))\n\nrun_basic_sql_queries()", "code_hash": "d27b1c1b4947b7d50c2f88af3a12eb31", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "SFPL", "name": "_"}, {"code": "def run_advanced_sql_queries():\n    # Advanced SQL queries with joins\n    print(\"\ud83d\udd17 Advanced SQL Queries with Joins\")\n    print(\"=\" * 45)\n\n    # Cells with their expression summary\n    print(\"\\n1. Top 5 cells by total expression:\")\n    top_cells = slaf.query(\n        \"\"\"\n        SELECT\n            c.cell_id,\n            c.total_counts,\n            COUNT(e.value) as expressed_genes,\n            AVG(e.value) as avg_expression\n        FROM cells c\n        LEFT JOIN expression e ON c.cell_integer_id = e.cell_integer_id\n        GROUP BY c.cell_id, c.total_counts\n        ORDER BY c.total_counts DESC\n        LIMIT 5\n    \"\"\"\n    )\n    print(top_cells.to_string(index=False))\n\n    # Highly variable genes with expression stats\n    print(\"\\n2. Highly variable genes with expression stats:\")\n    hvg_stats = slaf.query(\n        \"\"\"\n        SELECT\n            g.gene_id,\n            g.highly_variable,\n            COUNT(e.value) as cells_expressed,\n            AVG(e.value) as avg_expression,\n            MAX(e.value) as max_expression\n        FROM genes g\n        LEFT JOIN expression e ON g.gene_integer_id = e.gene_integer_id\n        WHERE g.highly_variable = true\n        GROUP BY g.gene_id, g.highly_variable\n        ORDER BY avg_expression DESC\n        LIMIT 5\n    \"\"\"\n    )\n    print(hvg_stats.to_string(index=False))\n\nrun_advanced_sql_queries()", "code_hash": "0b6fd260870913f7597c1396b8dcfc43", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "BYtC", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 2.5. Lazy Query Composition - Building Queries Step by Step\n\nSLAF provides `lazy_query()` for composable SQL operations. Unlike `query()` which executes immediately, `lazy_query()` lets you build complex queries step by step:\n\n**Key Benefits:**\n\n- \ud83d\udd04 **Composable**: Chain operations without materialization\n- \ud83d\udcbe **Memory Efficient**: Only execute when you call `.compute()`\n- \u26a1 **SQL Performance**: Leverage database-level optimizations\n- \ud83c\udfaf **Flexible**: Build queries dynamically based on conditions\n\"\"\"\n)", "code_hash": "ad81c0660ed971adeb2bf24bdb8a1d69", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "RGSE", "name": "_"}, {"code": "def demonstrate_lazy_query_composition():\n    print(\"\ud83d\udd27 Lazy Query Composition\")\n    print(\"=\" * 35)\n\n    print(\"1. Building a query step by step:\")\n\n    # Start with a base query\n    base_query = slaf.lazy_query(\"SELECT * FROM cells\")\n    print(f\"   Base query type: {type(base_query)}\")\n\n    # Add filtering\n    filtered_query = base_query.filter(\"total_counts > 1000\")\n    print(f\"   After filtering: {type(filtered_query)}\")\n\n    # Add selection\n    selected_query = filtered_query.select(\"cell_id, batch, total_counts\")\n    print(f\"   After selection: {type(selected_query)}\")\n\n    # Add grouping and aggregation\n    grouped_query = selected_query.group_by(\"batch\").select(\n        \"batch, COUNT(*) as count, AVG(total_counts) as avg_counts\"\n    )\n    print(f\"   After grouping: {type(grouped_query)}\")\n\n    # Add ordering\n    final_query = grouped_query.order_by(\"avg_counts DESC\")\n    print(f\"   Final query: {type(final_query)}\")\n\n    print(\"\\n2. Executing the composed query:\")\n    result = final_query.compute()\n    print(result.to_string(index=False))\n\n    return result\n\ndemonstrate_lazy_query_composition()", "code_hash": "925466b552518cd32f3b1559040247ab", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Kclp", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n### Understanding the Difference\n\nLet's compare `query()` vs `lazy_query()` to understand when to use each:\n\"\"\"\n)", "code_hash": "0bc2672354c6441588bd92ec99240857", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "emfo", "name": "_"}, {"code": "def compare_query_vs_lazy_query():\n    print(\"\u2696\ufe0f Query vs Lazy Query Comparison\")\n    print(\"=\" * 40)\n\n    print(\"1. Immediate execution with query():\")\n    # This executes immediately and returns DataFrame\n    start_time = time.time()\n    immediate_result = slaf.query(\n        \"\"\"\n        SELECT batch, COUNT(*) as count, AVG(total_counts) as avg_counts\n        FROM cells\n        WHERE total_counts > 1000\n        GROUP BY batch\n        ORDER BY avg_counts DESC\n    \"\"\"\n    )\n    immediate_time = time.time() - start_time\n    print(f\"   Execution time: {immediate_time:.4f}s\")\n    print(f\"   Result type: {type(immediate_result)}\")\n\n    print(\"\\n2. Lazy composition with lazy_query():\")\n    # This builds the query step by step\n    start_time = time.time()\n    lazy_query = slaf.lazy_query(\"SELECT * FROM cells\")\n    lazy_query = lazy_query.filter(\"total_counts > 1000\")\n    lazy_query = lazy_query.select(\"batch, total_counts\")\n    lazy_query = lazy_query.group_by(\"batch\").select(\n        \"batch, COUNT(*) as count, AVG(total_counts) as avg_counts\"\n    )\n    lazy_query = lazy_query.order_by(\"avg_counts DESC\")\n    build_time = time.time() - start_time\n\n    # Execute the composed query\n    start_time = time.time()\n    lazy_result = lazy_query.compute()\n    compute_time = time.time() - start_time\n\n    print(f\"   Build time: {build_time:.4f}s\")\n    print(f\"   Compute time: {compute_time:.4f}s\")\n    print(f\"   Total time: {build_time + compute_time:.4f}s\")\n    print(f\"   Result type: {type(lazy_result)}\")\n\n    print(\"\\n3. Key differences:\")\n    print(\"   - query(): Executes immediately, returns DataFrame\")\n    print(\"   - lazy_query(): Returns LazyQuery object for composition\")\n    print(\"   - lazy_query(): Can chain operations without materialization\")\n    print(\"   - lazy_query(): Only executes when .compute() is called\")\n\n    return immediate_result, lazy_result\n\nimport time\n\nimmediate_result, lazy_result = compare_query_vs_lazy_query()", "code_hash": "26eb90f890528dcb41e0d3f80b0279d0", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Hstk", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 3. Convenience Methods - Easy Filtering\n\nSLAF provides convenient methods for common operations:\n\"\"\"\n)", "code_hash": "f71e589f91cbb154bfe989cdf9331d63", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "nWHF", "name": "_"}, {"code": "# Demonstrate convenience methods\nprint(\"\ud83c\udfaf Convenience Methods\")\nprint(\"=\" * 30)\n\n# Filter cells\nprint(\"\\n1. Filter cells by criteria:\")\n\n# High quality cells\nhigh_quality = slaf.filter_cells(n_genes_by_counts=\">=1000\", total_counts=\">=2000\")\nprint(f\"   High quality cells (\u22651000 genes, \u22652000 counts): {len(high_quality):,}\")\n\n# Filter genes\nprint(\"\\n2. Filter genes by criteria:\")\n\n# Highly variable genes\nhvg_genes = slaf.filter_genes(highly_variable=True)\nprint(f\"   Highly variable genes: {len(hvg_genes):,}\")\n", "code_hash": "119277db3d5a15daf110e5425709211a", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "iLit", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 4. Lazy AnnData Interface - Scanpy Compatible\n\nSLAF provides a lazy AnnData interface that's compatible with scanpy workflows:\n\"\"\"\n)", "code_hash": "16e98556742b73202d25110f4287c875", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ZHCJ", "name": "_"}, {"code": "# Load as lazy AnnData\nadata = read_slaf(\"../slaf-datasets/pbmc3k_processed.slaf\")\nprint(\n    f\"\u2705 Loaded as LazyAnnData: {adata.shape[0]:,} cells \u00d7 {adata.shape[1]:,} genes\"\n)\nprint(f\"   Type: {type(adata)}\")\nprint(f\"   Expression matrix type: {type(adata.X)}\")", "code_hash": "ad1a54b4a57e9effe7589a544773c32c", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ROlb", "name": "_"}, {"code": "# Basic AnnData operations\nprint(\"\ud83d\udd2c Basic AnnData Operations\")\nprint(\"=\" * 35)\n\nprint(f\"Dataset shape: {adata.shape}\")\nprint(f\"Number of cells: {adata.n_obs}\")\nprint(f\"Number of genes: {adata.n_vars}\")\n\n# Show available metadata\nif hasattr(adata, \"obs\") and adata.obs is not None:\n    print(f\"\\nCell metadata columns: {list(adata.obs.columns)}\")\n\nif hasattr(adata, \"var\") and adata.var is not None:\n    print(f\"Gene metadata columns: {list(adata.var.columns)}\")\n", "code_hash": "b11d460e9b1001f81a2bb9a7a1a3c138", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "qnkX", "name": "_"}, {"code": "# Lazy slicing operations\nprint(\"\u2702\ufe0f Lazy Slicing Operations\")\nprint(\"=\" * 30)\n\n# Slice cells\nsubset_cells = adata[:100, :]\nprint(f\"First 100 cells subset: {subset_cells.shape}\")\n\n# Slice genes\nsubset_genes = adata[:, :50]\nprint(f\"First 50 genes subset: {subset_genes.shape}\")\n\n# Combined slice\nsubset_both = adata[:50, :25]\nprint(f\"50 cells \u00d7 25 genes subset: {subset_both.shape}\")\n\nprint(\"\\nNote: These operations are lazy - no data is loaded until needed!\")\n", "code_hash": "f1e5282264da29e549cc916dcc92657a", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "TqIu", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 5. Lazy Scanpy Preprocessing\n\nSLAF provides lazy versions of scanpy preprocessing functions:\n\"\"\"\n)", "code_hash": "7c327356b3e44ea802a05ebae242f163", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Vxnm", "name": "_"}, {"code": "# Lazy scanpy preprocessing\nprint(\"\ud83e\uddec Lazy Scanpy Preprocessing\")\nprint(\"=\" * 35)\n\n# Calculate QC metrics (lazy)\nprint(\"1. Calculating QC metrics...\")\nslaf_scanpy.pp.calculate_qc_metrics(adata, inplace=True)\nprint(\"   \u2705 QC metrics calculated (lazily)\")\n\n# Filter cells (lazy)\nprint(\"\\n2. Filtering cells...\")\nslaf_scanpy.pp.filter_cells(adata, min_genes=200, inplace=True)\nprint(\"   \u2705 Cells filtered (lazily)\")\n\n# Filter genes (lazy)\nprint(\"\\n3. Filtering genes...\")\nslaf_scanpy.pp.filter_genes(adata, min_cells=30, inplace=True)\nprint(\"   \u2705 Genes filtered (lazily)\")\n\nprint(f\"\\nFinal dataset shape: {adata.shape[0]:,} cells \u00d7 {adata.shape[1]:,} genes\")\nprint(\"Note: All operations are lazy - data is only processed when accessed!\")\n", "code_hash": "9e286c215bff4cecfb2caf3286f80dff", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "DnEU", "name": "_"}, {"code": "# Demonstrate .compute() method\nprint(\"\u26a1 Explicit Computation with .compute()\")\nprint(\"=\" * 40)\n\nprint(\"1. Computing full dataset:\")\nprint(f\"   Before: {type(adata)}\")\nnative_adata = adata.compute()\nprint(f\"   After: {type(native_adata)}\")\nprint(f\"   Shape: {native_adata.shape}\")\n\nprint(\"\\n2. Computing expression matrix only:\")\nprint(f\"   Before: {type(adata.X)}\")\nsparse_matrix = adata.X.compute()\nprint(f\"   After: {type(sparse_matrix)}\")\nprint(f\"   Shape: {sparse_matrix.shape}\")\n\nprint(\"\\n3. Computing sliced data:\")\nprint(f\"   Slice type: {type(subset_cells)}\")\nnative_slice = subset_cells.compute()\nprint(f\"   Computed slice type: {type(native_slice)}\")\nprint(f\"   Shape: {native_slice.shape}\")\n\nprint(\"\\nKey insight: .compute() converts lazy objects to native scanpy objects!\")\n", "code_hash": "812c1085af2f5c902318d0fd75dc0b68", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ulZA", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 6. Performance Characteristics\n\nLet's examine SLAF's performance characteristics:\n\"\"\"\n)", "code_hash": "63649134c4ad55401bfea160d7840571", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ecfG", "name": "_"}, {"code": "def examine_performance_characteristics():\n    import time\n\n    print(\"\u26a1 Performance Characteristics\")\n    print(\"=\" * 35)\n\n    # Test cell filtering performance\n    print(\"\\n1. Cell filtering performance:\")\n\n    # SLAF SQL approach\n    start_time = time.time()\n    _ = slaf.query(\"SELECT COUNT(*) FROM cells WHERE n_genes_by_counts > 500\")\n    slaf_time = time.time() - start_time\n    print(f\"   SLAF SQL: {slaf_time:.4f}s\")\n\n    # SLAF convenience method\n    start_time = time.time()\n    _ = slaf.filter_cells(n_genes_by_counts=\">500\")\n    slaf_filter_time = time.time() - start_time\n    print(f\"   SLAF filter method: {slaf_filter_time:.4f}s\")\n\n    # Test expression aggregation\n    print(\"\\n2. Expression aggregation performance:\")\n\n    # SLAF SQL aggregation\n    start_time = time.time()\n    _ = slaf.query(\"SELECT AVG(value) FROM expression\")\n    slaf_agg_time = time.time() - start_time\n    print(f\"   SLAF SQL aggregation: {slaf_agg_time:.4f}s\")\n\n    # Lazy AnnData approach (when computed)\n    print(\"   Lazy AnnData: Operations stored, computed on demand\")\n\nexamine_performance_characteristics()\n", "code_hash": "debb0600c8435e5fbc8f51ac985c343e", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Pvdt", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 8. Quick Tokenization Example\n\nSLAF provides efficient tokenization for ML training:\n\"\"\"\n)", "code_hash": "9ec0632db45f391d4c7be0d23fd14da0", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ZBYS", "name": "_"}, {"code": "# Quick tokenization example\nfrom slaf.ml.tokenizers import SLAFTokenizer\n\nprint(\"\ud83c\udfaf Quick Tokenization Example\")\nprint(\"=\" * 35)\n\n# Initialize tokenizer\ntokenizer = SLAFTokenizer(slaf, vocab_size=1000, n_expression_bins=10)\nprint(\n    f\"\u2705 Tokenizer initialized with {tokenizer.get_vocab_info()['total_vocab_size']} total tokens\"\n)\n\n# Get a small batch of cells\n\n# Tokenize for Geneformer\nprint(\"\\n1. Geneformer tokenization:\")\ngeneformer_tokens = tokenizer.tokenize_geneformer((0, 32), max_genes=100)\nprint(f\"   Generated {len(geneformer_tokens)} token sequences\")\nprint(\n    f\"   Average sequence length: {int(np.mean([len(seq) for seq in geneformer_tokens])):d}\"\n)\n\n# Tokenize for scGPT\nprint(\"\\n2. scGPT tokenization:\")\nscgpt_tokens = tokenizer.tokenize_scgpt((0, 32), max_genes=100)\nprint(f\"   Generated {len(scgpt_tokens)} token sequences\")\nprint(\n    f\"   Average sequence length: {int(np.mean([len(seq) for seq in scgpt_tokens])):d}\"\n)\n", "code_hash": "640134c95cdf21c8dfc10df1c63f1f51", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "aLJB", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## Summary\n\n    **What you've learned:**\n\n1. **SQL Schema**: SLAF stores data in 3 tables (cells, genes, expression) that you can query directly\n2. **SQL Power**: Direct SQL access for complex queries and aggregations\n3. **Lazy Queries**: Use `lazy_query()` for composable SQL operations that build step by step\n4. **Convenience Methods**: Easy filtering with `filter_cells()` and `filter_genes()`\n5. **Lazy AnnData**: Scanpy-compatible interface with lazy evaluation\n6. **Lazy Preprocessing**: scanpy functions that work lazily\n7. **Performance**: SQL-level performance for data operations\n8. **Explicit Computation**: Use `.compute()` to convert lazy objects to native Python objects\n9. **Tokenization**: Ready for ML training with efficient tokenization\n\n**Next Steps:**\n\n- **02-lazy-processing.py**: Deep dive into lazy evaluation capabilities\n\n- **03-ml-training-pipeline.py**: Complete ML training workflows\n\"\"\"\n)", "code_hash": "7c8b8c90dca66efe69a75a2673e8bc8d", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "nHfw", "name": "_"}], "metadata": {"marimo_version": "0.14.0"}, "version": "1"},
            "session": {"cells": [{"code_hash": "20d4e7813f7e3b8e7027c5d90376db59", "console": [], "id": "Hbol", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "cbc43f7eb0a77091897e6c3ab88eb932", "console": [], "id": "MJUe", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h1 id=\"slaf-getting-started-guide\">SLAF Getting Started Guide</h1>\n<span class=\"paragraph\">This notebook introduces SLAF (Sparse Lazy Array Format) - a high-performance format for single-cell data that combines the power of SQL with lazy evaluation.</span>\n<span class=\"paragraph\"><strong>Key Benefits:</strong></span>\n<ul>\n<li>\n<span class=\"paragraph\">\ud83d\ude80 <strong>Fast</strong>: SQL-level performance for data operations</span>\n</li>\n<li>\n<span class=\"paragraph\">\ud83d\udcbe <strong>Memory Efficient</strong>: Lazy evaluation, only load what you need</span>\n</li>\n<li>\n<span class=\"paragraph\">\ud83d\udd0d <strong>SQL Native</strong>: Direct SQL queries on your data</span>\n</li>\n<li>\n<span class=\"paragraph\">\ud83e\uddec <strong>Scanpy Compatible</strong>: Drop-in replacement for AnnData workflows</span>\n</li>\n<li>\n<span class=\"paragraph\">\u26a1 <strong>Production Ready</strong>: Built for large-scale single-cell analysis</span>\n</li>\n<li>\n<span class=\"paragraph\">\u2699\ufe0f <strong>ML Ready</strong>: Ready for ML training with efficient tokenization</span>\n</li>\n</ul></span>"}, "type": "data"}]}, {"code_hash": "b972ed512c4117db3c57c302d9fec088", "console": [{"name": "stdout", "text": "\u2705 Loaded SLAF dataset: 2,695 cells \u00d7 1,863 genes\nSLAF Dataset\n  Shape: 2695 cells \u00d7 1863 genes\n  Format version: 0.1\n  Cell metadata columns: 9\n    n_genes, n_genes_by_counts, total_counts, leiden, batch...\n  Gene metadata columns: 12\n    gene_ids, n_cells, mt, n_cells_by_counts, mean_counts...\n  Record counts:\n    Cells: 2,695\n    Genes: 1,863\n    Expression records: computing...\n    Expression records: 415,134\n  Optimizations:\n    use_integer_keys: True\n", "type": "stream"}], "id": "vblA", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "774279e6925bf51e4933ebd96d6f9462", "console": [], "id": "bkHC", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"1-understanding-the-slaf-database-schema\">1. Understanding the SLAF Database Schema</h2>\n<span class=\"paragraph\">SLAF stores data in three main tables that you can query directly with SQL:</span></span>"}, "type": "data"}]}, {"code_hash": "a0a0dde4f016fde99dbbecc2adcec0f6", "console": [{"name": "stdout", "text": "\ud83d\udcca SLAF Database Schema\n==================================================\n\n\ud83d\udd0d Table: cells\n   Purpose: Cell metadata and QC metrics\n   Key columns:\n     - cell_id: Unique cell identifier\n     - cell_integer_id: Integer ID for efficient queries\n     - batch: Batch information\n     - total_counts: Total UMI counts per cell\n     - n_genes_by_counts: Number of genes expressed\n     - high_mito: Boolean flag for high mitochondrial content\n\n\ud83d\udd0d Table: genes\n   Purpose: Gene metadata and annotations\n   Key columns:\n     - gene_id: Unique gene identifier\n     - gene_integer_id: Integer ID for efficient queries\n     - highly_variable: Boolean flag for highly variable genes\n\n\ud83d\udd0d Table: expression\n   Purpose: Sparse expression matrix data\n   Key columns:\n     - cell_id: Cell identifier (foreign key)\n     - gene_id: Gene identifier (foreign key)\n     - cell_integer_id: Integer cell ID for efficient queries\n     - gene_integer_id: Integer gene ID for efficient queries\n     - value: Expression value (UMI counts)\n", "type": "stream"}], "id": "lEQa", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "6bd63b5cd8660f224e3b27cd6f3d0470", "console": [{"name": "stdout", "text": "\ud83d\udccb Sample Data from Each Table\n==================================================\n\n\ud83d\udd2c Sample cells:\n n_genes  n_genes_by_counts  total_counts leiden   batch  high_mito  pct_counts_mt  high_genes          cell_id  cell_integer_id\n     779                779        2419.0      0 batch_1      False            0.0       False AAACATACAACCAC-1                0\n    1352               1352        4903.0      3 batch_1      False            0.0       False AAACATTGAGCTAC-1                1\n    1129               1129        3147.0      0 batch_1      False            0.0       False AAACATTGATCAGC-1                2\n\n\ud83e\uddec Sample genes:\n       gene_ids  n_cells    mt  n_cells_by_counts  mean_counts  pct_dropout_by_counts  total_counts  highly_variable    means  dispersions  dispersions_norm gene_id  gene_integer_id\nENSG00000186827      155 False                155     0.077407              94.259259         209.0             True 0.274771     2.087092          0.618207 TNFRSF4                0\nENSG00000127054      202 False                202     0.094815              92.518519         256.0             True 0.379642     4.503354          2.951207  CPSF3L                1\nENSG00000215915        9 False                  9     0.009259              99.666667          25.0             True 0.037458     3.953494          4.275361  ATAD3C                2\n\n\ud83d\udcc8 Sample expression data:\n", "type": "stream"}, {"name": "stdout", "text": "         cell_id  gene_id  cell_integer_id  gene_integer_id    value\nAAACATACAACCAC-1 TNFRSF25                0                5 2.226555\nAAACATACAACCAC-1    CAPZB                0               16 1.635873\nAAACATACAACCAC-1   PITHD1                0               24 1.635873\nAAACATACAACCAC-1    RRAGC                0               48 1.635873\nAAACATACAACCAC-1     PPT1                0               52 1.635873\n", "type": "stream"}], "id": "PKri", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "dc72ee1631e56f8b726513287b28a2de", "console": [], "id": "Xref", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"2-sql-queries-your-data-your-way\">2. SQL Queries - Your Data, Your Way</h2>\n<span class=\"paragraph\">SLAF gives you direct SQL access to your data. Here are some practical examples:</span></span>"}, "type": "data"}]}, {"code_hash": "d27b1c1b4947b7d50c2f88af3a12eb31", "console": [{"name": "stdout", "text": "\ud83d\udd0d Basic SQL Queries\n========================================\n\n1. Count records in each table:\n   cells: 2,695 records\n   genes: 1,863 records\n   expression: 415,134 records\n\n2. Batch distribution:\n", "type": "stream"}, {"name": "stdout", "text": "  batch  count\nbatch_2   1348\nbatch_1   1347\n\n3. Expression value statistics:\n min_expr  max_expr  avg_expr  total_records  non_zero_records\n   0.7546  7.145171   1.86466         415134            415134\n", "type": "stream"}], "id": "SFPL", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "0b6fd260870913f7597c1396b8dcfc43", "console": [{"name": "stdout", "text": "\ud83d\udd17 Advanced SQL Queries with Joins\n=============================================\n\n1. Top 5 cells by total expression:\n", "type": "stream"}, {"name": "stdout", "text": "         cell_id  total_counts  expressed_genes  avg_expression\nACGAACTGGCTATG-1        8875.0              503        1.271669\nGGGCCAACCTTGGA-1        8415.0              403        1.119208\nCAGGTTGAGGATCT-1        8011.0              379        1.128478\nACGAGGGACAGGAG-1        7928.0              390        1.176331\nCATACTTGGGTTAC-1        7167.0              376        1.183759\n\n2. Highly variable genes with expression stats:\n", "type": "stream"}, {"name": "stdout", "text": "gene_id  highly_variable  cells_expressed  avg_expression  max_expression\n S100A8             True              741        3.234808        5.953327\n TYROBP             True             1068        3.187407        5.704022\n   CST3             True             1071        3.167506        5.551714\n    GP9             True               16        3.029735        4.488373\n   NKG7             True              813        3.009491        5.948639\n", "type": "stream"}], "id": "BYtC", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "ad81c0660ed971adeb2bf24bdb8a1d69", "console": [], "id": "RGSE", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"25-lazy-query-composition-building-queries-step-by-step\">2.5. Lazy Query Composition - Building Queries Step by Step</h2>\n<span class=\"paragraph\">SLAF provides <code>lazy_query()</code> for composable SQL operations. Unlike <code>query()</code> which executes immediately, <code>lazy_query()</code> lets you build complex queries step by step:</span>\n<span class=\"paragraph\"><strong>Key Benefits:</strong></span>\n<ul>\n<li>\ud83d\udd04 <strong>Composable</strong>: Chain operations without materialization</li>\n<li>\ud83d\udcbe <strong>Memory Efficient</strong>: Only execute when you call <code>.compute()</code></li>\n<li>\u26a1 <strong>SQL Performance</strong>: Leverage database-level optimizations</li>\n<li>\ud83c\udfaf <strong>Flexible</strong>: Build queries dynamically based on conditions</li>\n</ul></span>"}, "type": "data"}]}, {"code_hash": "925466b552518cd32f3b1559040247ab", "console": [{"name": "stdout", "text": "\ud83d\udd27 Lazy Query Composition\n===================================\n1. Building a query step by step:\n   Base query type: <class 'slaf.core.lazy_query.LazyQuery'>\n   After filtering: <class 'slaf.core.lazy_query.LazyQuery'>\n   After selection: <class 'slaf.core.lazy_query.LazyQuery'>\n   After grouping: <class 'slaf.core.lazy_query.LazyQuery'>\n   Final query: <class 'slaf.core.lazy_query.LazyQuery'>\n\n2. Executing the composed query:\n  batch  count  avg_counts\nbatch_1   1269 2443.996848\nbatch_2   1272 2437.472484\n", "type": "stream"}], "id": "Kclp", "outputs": [{"data": {"text/html": "<marimo-ui-element object-id='Kclp-0' random-id='34f15a1e-8409-696a-2bf0-3ac207b3b8b7'><marimo-table data-initial-value='[]' data-label='null' data-data='&quot;[{&#92;&quot;batch&#92;&quot;:&#92;&quot;batch_1&#92;&quot;,&#92;&quot;count&#92;&quot;:1269,&#92;&quot;avg_counts&#92;&quot;:2443.9968479117},{&#92;&quot;batch&#92;&quot;:&#92;&quot;batch_2&#92;&quot;,&#92;&quot;count&#92;&quot;:1272,&#92;&quot;avg_counts&#92;&quot;:2437.4724842767}]&quot;' data-total-rows='2' data-total-columns='3' data-max-columns='50' data-banner-text='&quot;&quot;' data-pagination='true' data-page-size='10' data-field-types='[[&quot;batch&quot;, [&quot;string&quot;, &quot;object&quot;]], [&quot;count&quot;, [&quot;integer&quot;, &quot;int64&quot;]], [&quot;avg_counts&quot;, [&quot;number&quot;, &quot;float64&quot;]]]' data-show-filters='true' data-show-download='true' data-show-column-summaries='false' data-row-headers='[]' data-has-stable-row-id='false' data-lazy='false' data-preload='false'></marimo-table></marimo-ui-element>"}, "type": "data"}]}, {"code_hash": "0bc2672354c6441588bd92ec99240857", "console": [], "id": "emfo", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h3 id=\"understanding-the-difference\">Understanding the Difference</h3>\n<span class=\"paragraph\">Let's compare <code>query()</code> vs <code>lazy_query()</code> to understand when to use each:</span></span>"}, "type": "data"}]}, {"code_hash": "26eb90f890528dcb41e0d3f80b0279d0", "console": [{"name": "stdout", "text": "\u2696\ufe0f Query vs Lazy Query Comparison\n========================================\n1. Immediate execution with query():\n   Execution time: 0.0028s\n   Result type: <class 'pandas.core.frame.DataFrame'>\n\n2. Lazy composition with lazy_query():\n   Build time: 0.0001s\n   Compute time: 0.0057s\n   Total time: 0.0058s\n   Result type: <class 'pandas.core.frame.DataFrame'>\n\n3. Key differences:\n   - query(): Executes immediately, returns DataFrame\n   - lazy_query(): Returns LazyQuery object for composition\n   - lazy_query(): Can chain operations without materialization\n   - lazy_query(): Only executes when .compute() is called\n", "type": "stream"}], "id": "Hstk", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "f71e589f91cbb154bfe989cdf9331d63", "console": [], "id": "nWHF", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"3-convenience-methods-easy-filtering\">3. Convenience Methods - Easy Filtering</h2>\n<span class=\"paragraph\">SLAF provides convenient methods for common operations:</span></span>"}, "type": "data"}]}, {"code_hash": "119277db3d5a15daf110e5425709211a", "console": [{"name": "stdout", "text": "\ud83c\udfaf Convenience Methods\n==============================\n\n1. Filter cells by criteria:\n   High quality cells (\u22651000 genes, \u22652000 counts): 524\n\n2. Filter genes by criteria:\n   Highly variable genes: 1,863\n", "type": "stream"}], "id": "iLit", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "16e98556742b73202d25110f4287c875", "console": [], "id": "ZHCJ", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"4-lazy-anndata-interface-scanpy-compatible\">4. Lazy AnnData Interface - Scanpy Compatible</h2>\n<span class=\"paragraph\">SLAF provides a lazy AnnData interface that's compatible with scanpy workflows:</span></span>"}, "type": "data"}]}, {"code_hash": "ad1a54b4a57e9effe7589a544773c32c", "console": [{"name": "stdout", "text": "\u2705 Loaded as LazyAnnData: 2,695 cells \u00d7 1,863 genes\n   Type: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Expression matrix type: <class 'slaf.integrations.anndata.LazyExpressionMatrix'>\n", "type": "stream"}], "id": "ROlb", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "b11d460e9b1001f81a2bb9a7a1a3c138", "console": [{"name": "stdout", "text": "\ud83d\udd2c Basic AnnData Operations\n===================================\nDataset shape: (2695, 1863)\nNumber of cells: 2695\nNumber of genes: 1863\n\nCell metadata columns: ['n_genes', 'n_genes_by_counts', 'total_counts', 'leiden', 'batch', 'high_mito', 'pct_counts_mt', 'high_genes']\nGene metadata columns: ['gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm']\n", "type": "stream"}], "id": "qnkX", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "f1e5282264da29e549cc916dcc92657a", "console": [{"name": "stdout", "text": "\u2702\ufe0f Lazy Slicing Operations\n==============================\nFirst 100 cells subset: (100, 1863)\nFirst 50 genes subset: (2695, 50)\n50 cells \u00d7 25 genes subset: (50, 25)\n\nNote: These operations are lazy - no data is loaded until needed!\n", "type": "stream"}], "id": "TqIu", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "7c327356b3e44ea802a05ebae242f163", "console": [], "id": "Vxnm", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"5-lazy-scanpy-preprocessing\">5. Lazy Scanpy Preprocessing</h2>\n<span class=\"paragraph\">SLAF provides lazy versions of scanpy preprocessing functions:</span></span>"}, "type": "data"}]}, {"code_hash": "9e286c215bff4cecfb2caf3286f80dff", "console": [{"name": "stdout", "text": "\ud83e\uddec Lazy Scanpy Preprocessing\n===================================\n1. Calculating QC metrics...\n", "type": "stream"}, {"name": "stdout", "text": "QC metrics stored as lazy queries - compute when needed\n   \u2705 QC metrics calculated (lazily)\n\n2. Filtering cells...\n", "type": "stream"}, {"name": "stdout", "text": "Filtered out 2245 cells, 450 remaining\n   \u2705 Cells filtered (lazily)\n\n3. Filtering genes...\n", "type": "stream"}, {"name": "stdout", "text": "Filtered out 372 genes, 1491 remaining\n   \u2705 Genes filtered (lazily)\n\nFinal dataset shape: 2,695 cells \u00d7 1,863 genes\nNote: All operations are lazy - data is only processed when accessed!\n", "type": "stream"}], "id": "DnEU", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "812c1085af2f5c902318d0fd75dc0b68", "console": [{"name": "stdout", "text": "\u26a1 Explicit Computation with .compute()\n========================================\n1. Computing full dataset:\n   Before: <class 'slaf.integrations.anndata.LazyAnnData'>\n", "type": "stream"}, {"name": "stdout", "text": "   After: <class 'anndata._core.anndata.AnnData'>\n   Shape: (2695, 1863)\n\n2. Computing expression matrix only:\n   Before: <class 'slaf.integrations.anndata.LazyExpressionMatrix'>\n", "type": "stream"}, {"name": "stdout", "text": "   After: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (2695, 1863)\n\n3. Computing sliced data:\n   Slice type: <class 'slaf.integrations.anndata.LazyAnnData'>\n", "type": "stream"}, {"name": "stdout", "text": "   Computed slice type: <class 'anndata._core.anndata.AnnData'>\n   Shape: (100, 1863)\n\nKey insight: .compute() converts lazy objects to native scanpy objects!\n", "type": "stream"}], "id": "ulZA", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "63649134c4ad55401bfea160d7840571", "console": [], "id": "ecfG", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"6-performance-characteristics\">6. Performance Characteristics</h2>\n<span class=\"paragraph\">Let's examine SLAF's performance characteristics:</span></span>"}, "type": "data"}]}, {"code_hash": "debb0600c8435e5fbc8f51ac985c343e", "console": [{"name": "stdout", "text": "\u26a1 Performance Characteristics\n===================================\n\n1. Cell filtering performance:\n   SLAF SQL: 0.0032s\n   SLAF filter method: 0.0006s\n\n2. Expression aggregation performance:\n", "type": "stream"}, {"name": "stdout", "text": "   SLAF SQL aggregation: 0.0024s\n   Lazy AnnData: Operations stored, computed on demand\n", "type": "stream"}], "id": "Pvdt", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "9ec0632db45f391d4c7be0d23fd14da0", "console": [], "id": "ZBYS", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"8-quick-tokenization-example\">8. Quick Tokenization Example</h2>\n<span class=\"paragraph\">SLAF provides efficient tokenization for ML training:</span></span>"}, "type": "data"}]}, {"code_hash": "640134c95cdf21c8dfc10df1c63f1f51", "console": [{"name": "stdout", "text": "\ud83c\udfaf Quick Tokenization Example\n===================================\n\u2705 Tokenizer initialized with 1014 total tokens\n\n1. Geneformer tokenization:\n", "type": "stream"}, {"name": "stdout", "text": "   Generated 32 token sequences\n   Average sequence length: 100\n\n2. scGPT tokenization:\n   Generated 32 token sequences\n   Average sequence length: 202\n", "type": "stream"}], "id": "aLJB", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "7c8b8c90dca66efe69a75a2673e8bc8d", "console": [], "id": "nHfw", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"summary\">Summary</h2>\n<span class=\"paragraph\"><strong>What you've learned:</strong></span>\n<ol>\n<li><strong>SQL Schema</strong>: SLAF stores data in 3 tables (cells, genes, expression) that you can query directly</li>\n<li><strong>SQL Power</strong>: Direct SQL access for complex queries and aggregations</li>\n<li><strong>Lazy Queries</strong>: Use <code>lazy_query()</code> for composable SQL operations that build step by step</li>\n<li><strong>Convenience Methods</strong>: Easy filtering with <code>filter_cells()</code> and <code>filter_genes()</code></li>\n<li><strong>Lazy AnnData</strong>: Scanpy-compatible interface with lazy evaluation</li>\n<li><strong>Lazy Preprocessing</strong>: scanpy functions that work lazily</li>\n<li><strong>Performance</strong>: SQL-level performance for data operations</li>\n<li><strong>Explicit Computation</strong>: Use <code>.compute()</code> to convert lazy objects to native Python objects</li>\n<li><strong>Tokenization</strong>: Ready for ML training with efficient tokenization</li>\n</ol>\n<span class=\"paragraph\"><strong>Next Steps:</strong></span>\n<ul>\n<li>\n<span class=\"paragraph\"><strong>02-lazy-processing.py</strong>: Deep dive into lazy evaluation capabilities</span>\n</li>\n<li>\n<span class=\"paragraph\"><strong>03-ml-training-pipeline.py</strong>: Complete ML training workflows</span>\n</li>\n</ul></span>"}, "type": "data"}]}], "metadata": {"marimo_version": "0.14.0"}, "version": "1"},
            "runtimeConfig": null,
        };
    </script>

<marimo-code hidden="">
    import%20marimo%0A%0A__generated_with%20%3D%20%220.14.0%22%0Aapp%20%3D%20marimo.App(width%3D%22medium%22)%0A%0A%0A%40app.cell%0Adef%20_()%3A%0A%20%20%20%20import%20marimo%20as%20mo%0A%20%20%20%20import%20numpy%20as%20np%0A%0A%20%20%20%20from%20slaf%20import%20SLAFArray%0A%20%20%20%20from%20slaf.integrations%20import%20scanpy%20as%20slaf_scanpy%0A%20%20%20%20from%20slaf.integrations.anndata%20import%20read_slaf%0A%0A%20%20%20%20return%20SLAFArray%2C%20mo%2C%20np%2C%20read_slaf%2C%20slaf_scanpy%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%20SLAF%20Getting%20Started%20Guide%0A%0A%20%20%20%20This%20notebook%20introduces%20SLAF%20(Sparse%20Lazy%20Array%20Format)%20-%20a%20high-performance%20format%20for%20single-cell%20data%20that%20combines%20the%20power%20of%20SQL%20with%20lazy%20evaluation.%0A%0A%20%20%20%20**Key%20Benefits%3A**%0A%0A%20%20%20%20-%20%F0%9F%9A%80%20**Fast**%3A%20SQL-level%20performance%20for%20data%20operations%0A%0A%20%20%20%20-%20%F0%9F%92%BE%20**Memory%20Efficient**%3A%20Lazy%20evaluation%2C%20only%20load%20what%20you%20need%0A%0A%20%20%20%20-%20%F0%9F%94%8D%20**SQL%20Native**%3A%20Direct%20SQL%20queries%20on%20your%20data%0A%0A%20%20%20%20-%20%F0%9F%A7%AC%20**Scanpy%20Compatible**%3A%20Drop-in%20replacement%20for%20AnnData%20workflows%0A%0A%20%20%20%20-%20%E2%9A%A1%20**Production%20Ready**%3A%20Built%20for%20large-scale%20single-cell%20analysis%0A%0A%20%20%20%20-%20%E2%9A%99%EF%B8%8F%20**ML%20Ready**%3A%20Ready%20for%20ML%20training%20with%20efficient%20tokenization%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(SLAFArray)%3A%0A%20%20%20%20%23%20Load%20SLAF%20dataset%20using%20the%20low-level%20interface%0A%20%20%20%20slaf%20%3D%20SLAFArray(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%20%20%20%20print(f%22%E2%9C%85%20Loaded%20SLAF%20dataset%3A%20%7Bslaf.shape%5B0%5D%3A%2C%7D%20cells%20%C3%97%20%7Bslaf.shape%5B1%5D%3A%2C%7D%20genes%22)%0A%0A%20%20%20%20%23%20Show%20dataset%20information%0A%20%20%20%20slaf.info()%0A%20%20%20%20return%20(slaf%2C)%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%201.%20Understanding%20the%20SLAF%20Database%20Schema%0A%0A%20%20%20%20SLAF%20stores%20data%20in%20three%20main%20tables%20that%20you%20can%20query%20directly%20with%20SQL%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_()%3A%0A%20%20%20%20def%20show_database_schema()%3A%0A%20%20%20%20%20%20%20%20%23%20Show%20the%20database%20schema%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%93%8A%20SLAF%20Database%20Schema%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2050)%0A%0A%20%20%20%20%20%20%20%20%23%20Get%20table%20information%0A%20%20%20%20%20%20%20%20tables%20%3D%20%5B%22cells%22%2C%20%22genes%22%2C%20%22expression%22%5D%0A%0A%20%20%20%20%20%20%20%20for%20table%20in%20tables%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%5Cn%F0%9F%94%8D%20Table%3A%20%7Btable%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20table%20%3D%3D%20%22cells%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Purpose%3A%20Cell%20metadata%20and%20QC%20metrics%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Key%20columns%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20cell_id%3A%20Unique%20cell%20identifier%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20cell_integer_id%3A%20Integer%20ID%20for%20efficient%20queries%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20batch%3A%20Batch%20information%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20total_counts%3A%20Total%20UMI%20counts%20per%20cell%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20n_genes_by_counts%3A%20Number%20of%20genes%20expressed%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20high_mito%3A%20Boolean%20flag%20for%20high%20mitochondrial%20content%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20elif%20table%20%3D%3D%20%22genes%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Purpose%3A%20Gene%20metadata%20and%20annotations%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Key%20columns%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20gene_id%3A%20Unique%20gene%20identifier%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20gene_integer_id%3A%20Integer%20ID%20for%20efficient%20queries%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20highly_variable%3A%20Boolean%20flag%20for%20highly%20variable%20genes%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20elif%20table%20%3D%3D%20%22expression%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Purpose%3A%20Sparse%20expression%20matrix%20data%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20Key%20columns%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20cell_id%3A%20Cell%20identifier%20(foreign%20key)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20gene_id%3A%20Gene%20identifier%20(foreign%20key)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20cell_integer_id%3A%20Integer%20cell%20ID%20for%20efficient%20queries%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20gene_integer_id%3A%20Integer%20gene%20ID%20for%20efficient%20queries%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22%20%20%20%20%20-%20value%3A%20Expression%20value%20(UMI%20counts)%22)%0A%0A%20%20%20%20%20%20%20%20return%0A%0A%20%20%20%20show_database_schema()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20show_sample_data()%3A%0A%20%20%20%20%20%20%20%20%23%20Show%20sample%20data%20from%20each%20table%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%93%8B%20Sample%20Data%20from%20Each%20Table%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2050)%0A%0A%20%20%20%20%20%20%20%20%23%20Sample%20from%20cells%20table%0A%20%20%20%20%20%20%20%20print(%22%5Cn%F0%9F%94%AC%20Sample%20cells%3A%22)%0A%20%20%20%20%20%20%20%20cells_sample%20%3D%20slaf.query(%22SELECT%20*%20FROM%20cells%20LIMIT%203%22)%0A%20%20%20%20%20%20%20%20print(cells_sample.to_string(index%3DFalse))%0A%0A%20%20%20%20%20%20%20%20%23%20Sample%20from%20genes%20table%0A%20%20%20%20%20%20%20%20print(%22%5Cn%F0%9F%A7%AC%20Sample%20genes%3A%22)%0A%20%20%20%20%20%20%20%20genes_sample%20%3D%20slaf.query(%22SELECT%20*%20FROM%20genes%20LIMIT%203%22)%0A%20%20%20%20%20%20%20%20print(genes_sample.to_string(index%3DFalse))%0A%0A%20%20%20%20%20%20%20%20%23%20Sample%20from%20expression%20table%0A%20%20%20%20%20%20%20%20print(%22%5Cn%F0%9F%93%88%20Sample%20expression%20data%3A%22)%0A%20%20%20%20%20%20%20%20expr_sample%20%3D%20slaf.query(%22SELECT%20*%20FROM%20expression%20LIMIT%205%22)%0A%20%20%20%20%20%20%20%20print(expr_sample.to_string(index%3DFalse))%0A%0A%20%20%20%20show_sample_data()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%202.%20SQL%20Queries%20-%20Your%20Data%2C%20Your%20Way%0A%0A%20%20%20%20SLAF%20gives%20you%20direct%20SQL%20access%20to%20your%20data.%20Here%20are%20some%20practical%20examples%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20run_basic_sql_queries()%3A%0A%20%20%20%20%20%20%20%20%23%20Basic%20SQL%20queries%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%94%8D%20Basic%20SQL%20Queries%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2040)%0A%0A%20%20%20%20%20%20%20%20%23%20Count%20records%0A%20%20%20%20%20%20%20%20print(%22%5Cn1.%20Count%20records%20in%20each%20table%3A%22)%0A%20%20%20%20%20%20%20%20for%20table%20in%20%5B%22cells%22%2C%20%22genes%22%2C%20%22expression%22%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20count%20%3D%20slaf.query(f%22SELECT%20COUNT(*)%20as%20count%20FROM%20%7Btable%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%7Btable%7D%3A%20%7Bcount.iloc%5B0%5D%5B'count'%5D%3A%2C%7D%20records%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Batch%20distribution%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Batch%20distribution%3A%22)%0A%20%20%20%20%20%20%20%20batch_distribution%20%3D%20slaf.query(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20%20%20%20%20SELECT%20batch%2C%20COUNT(*)%20as%20count%0A%20%20%20%20%20%20%20%20%20%20%20%20FROM%20cells%0A%20%20%20%20%20%20%20%20%20%20%20%20GROUP%20BY%20batch%0A%20%20%20%20%20%20%20%20%20%20%20%20ORDER%20BY%20count%20DESC%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20print(batch_distribution.to_string(index%3DFalse))%0A%0A%20%20%20%20%20%20%20%20%23%20Expression%20statistics%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Expression%20value%20statistics%3A%22)%0A%20%20%20%20%20%20%20%20expr_stats%20%3D%20slaf.query(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20%20%20%20%20SELECT%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20MIN(value)%20as%20min_expr%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20MAX(value)%20as%20max_expr%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20AVG(value)%20as%20avg_expr%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20COUNT(*)%20as%20total_records%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20COUNT(CASE%20WHEN%20value%20%3E%200%20THEN%201%20END)%20as%20non_zero_records%0A%20%20%20%20%20%20%20%20%20%20%20%20FROM%20expression%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20print(expr_stats.to_string(index%3DFalse))%0A%0A%20%20%20%20run_basic_sql_queries()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20run_advanced_sql_queries()%3A%0A%20%20%20%20%20%20%20%20%23%20Advanced%20SQL%20queries%20with%20joins%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%94%97%20Advanced%20SQL%20Queries%20with%20Joins%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2045)%0A%0A%20%20%20%20%20%20%20%20%23%20Cells%20with%20their%20expression%20summary%0A%20%20%20%20%20%20%20%20print(%22%5Cn1.%20Top%205%20cells%20by%20total%20expression%3A%22)%0A%20%20%20%20%20%20%20%20top_cells%20%3D%20slaf.query(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20%20%20%20%20SELECT%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c.cell_id%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c.total_counts%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20COUNT(e.value)%20as%20expressed_genes%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20AVG(e.value)%20as%20avg_expression%0A%20%20%20%20%20%20%20%20%20%20%20%20FROM%20cells%20c%0A%20%20%20%20%20%20%20%20%20%20%20%20LEFT%20JOIN%20expression%20e%20ON%20c.cell_integer_id%20%3D%20e.cell_integer_id%0A%20%20%20%20%20%20%20%20%20%20%20%20GROUP%20BY%20c.cell_id%2C%20c.total_counts%0A%20%20%20%20%20%20%20%20%20%20%20%20ORDER%20BY%20c.total_counts%20DESC%0A%20%20%20%20%20%20%20%20%20%20%20%20LIMIT%205%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20print(top_cells.to_string(index%3DFalse))%0A%0A%20%20%20%20%20%20%20%20%23%20Highly%20variable%20genes%20with%20expression%20stats%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Highly%20variable%20genes%20with%20expression%20stats%3A%22)%0A%20%20%20%20%20%20%20%20hvg_stats%20%3D%20slaf.query(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20%20%20%20%20SELECT%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20g.gene_id%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20g.highly_variable%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20COUNT(e.value)%20as%20cells_expressed%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20AVG(e.value)%20as%20avg_expression%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20MAX(e.value)%20as%20max_expression%0A%20%20%20%20%20%20%20%20%20%20%20%20FROM%20genes%20g%0A%20%20%20%20%20%20%20%20%20%20%20%20LEFT%20JOIN%20expression%20e%20ON%20g.gene_integer_id%20%3D%20e.gene_integer_id%0A%20%20%20%20%20%20%20%20%20%20%20%20WHERE%20g.highly_variable%20%3D%20true%0A%20%20%20%20%20%20%20%20%20%20%20%20GROUP%20BY%20g.gene_id%2C%20g.highly_variable%0A%20%20%20%20%20%20%20%20%20%20%20%20ORDER%20BY%20avg_expression%20DESC%0A%20%20%20%20%20%20%20%20%20%20%20%20LIMIT%205%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20print(hvg_stats.to_string(index%3DFalse))%0A%0A%20%20%20%20run_advanced_sql_queries()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%202.5.%20Lazy%20Query%20Composition%20-%20Building%20Queries%20Step%20by%20Step%0A%0A%20%20%20%20SLAF%20provides%20%60lazy_query()%60%20for%20composable%20SQL%20operations.%20Unlike%20%60query()%60%20which%20executes%20immediately%2C%20%60lazy_query()%60%20lets%20you%20build%20complex%20queries%20step%20by%20step%3A%0A%0A%20%20%20%20**Key%20Benefits%3A**%0A%0A%20%20%20%20-%20%F0%9F%94%84%20**Composable**%3A%20Chain%20operations%20without%20materialization%0A%20%20%20%20-%20%F0%9F%92%BE%20**Memory%20Efficient**%3A%20Only%20execute%20when%20you%20call%20%60.compute()%60%0A%20%20%20%20-%20%E2%9A%A1%20**SQL%20Performance**%3A%20Leverage%20database-level%20optimizations%0A%20%20%20%20-%20%F0%9F%8E%AF%20**Flexible**%3A%20Build%20queries%20dynamically%20based%20on%20conditions%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20demonstrate_lazy_query_composition()%3A%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%94%A7%20Lazy%20Query%20Composition%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Building%20a%20query%20step%20by%20step%3A%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Start%20with%20a%20base%20query%0A%20%20%20%20%20%20%20%20base_query%20%3D%20slaf.lazy_query(%22SELECT%20*%20FROM%20cells%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Base%20query%20type%3A%20%7Btype(base_query)%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Add%20filtering%0A%20%20%20%20%20%20%20%20filtered_query%20%3D%20base_query.filter(%22total_counts%20%3E%201000%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20After%20filtering%3A%20%7Btype(filtered_query)%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Add%20selection%0A%20%20%20%20%20%20%20%20selected_query%20%3D%20filtered_query.select(%22cell_id%2C%20batch%2C%20total_counts%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20After%20selection%3A%20%7Btype(selected_query)%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Add%20grouping%20and%20aggregation%0A%20%20%20%20%20%20%20%20grouped_query%20%3D%20selected_query.group_by(%22batch%22).select(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22batch%2C%20COUNT(*)%20as%20count%2C%20AVG(total_counts)%20as%20avg_counts%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20After%20grouping%3A%20%7Btype(grouped_query)%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Add%20ordering%0A%20%20%20%20%20%20%20%20final_query%20%3D%20grouped_query.order_by(%22avg_counts%20DESC%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Final%20query%3A%20%7Btype(final_query)%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Executing%20the%20composed%20query%3A%22)%0A%20%20%20%20%20%20%20%20result%20%3D%20final_query.compute()%0A%20%20%20%20%20%20%20%20print(result.to_string(index%3DFalse))%0A%0A%20%20%20%20%20%20%20%20return%20result%0A%0A%20%20%20%20demonstrate_lazy_query_composition()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%23%20Understanding%20the%20Difference%0A%0A%20%20%20%20Let's%20compare%20%60query()%60%20vs%20%60lazy_query()%60%20to%20understand%20when%20to%20use%20each%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20compare_query_vs_lazy_query()%3A%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%96%EF%B8%8F%20Query%20vs%20Lazy%20Query%20Comparison%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2040)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Immediate%20execution%20with%20query()%3A%22)%0A%20%20%20%20%20%20%20%20%23%20This%20executes%20immediately%20and%20returns%20DataFrame%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20immediate_result%20%3D%20slaf.query(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20%20%20%20%20SELECT%20batch%2C%20COUNT(*)%20as%20count%2C%20AVG(total_counts)%20as%20avg_counts%0A%20%20%20%20%20%20%20%20%20%20%20%20FROM%20cells%0A%20%20%20%20%20%20%20%20%20%20%20%20WHERE%20total_counts%20%3E%201000%0A%20%20%20%20%20%20%20%20%20%20%20%20GROUP%20BY%20batch%0A%20%20%20%20%20%20%20%20%20%20%20%20ORDER%20BY%20avg_counts%20DESC%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20immediate_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Execution%20time%3A%20%7Bimmediate_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Result%20type%3A%20%7Btype(immediate_result)%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Lazy%20composition%20with%20lazy_query()%3A%22)%0A%20%20%20%20%20%20%20%20%23%20This%20builds%20the%20query%20step%20by%20step%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20lazy_query%20%3D%20slaf.lazy_query(%22SELECT%20*%20FROM%20cells%22)%0A%20%20%20%20%20%20%20%20lazy_query%20%3D%20lazy_query.filter(%22total_counts%20%3E%201000%22)%0A%20%20%20%20%20%20%20%20lazy_query%20%3D%20lazy_query.select(%22batch%2C%20total_counts%22)%0A%20%20%20%20%20%20%20%20lazy_query%20%3D%20lazy_query.group_by(%22batch%22).select(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22batch%2C%20COUNT(*)%20as%20count%2C%20AVG(total_counts)%20as%20avg_counts%22%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20lazy_query%20%3D%20lazy_query.order_by(%22avg_counts%20DESC%22)%0A%20%20%20%20%20%20%20%20build_time%20%3D%20time.time()%20-%20start_time%0A%0A%20%20%20%20%20%20%20%20%23%20Execute%20the%20composed%20query%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20lazy_result%20%3D%20lazy_query.compute()%0A%20%20%20%20%20%20%20%20compute_time%20%3D%20time.time()%20-%20start_time%0A%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Build%20time%3A%20%7Bbuild_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Compute%20time%3A%20%7Bcompute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Total%20time%3A%20%7Bbuild_time%20%2B%20compute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Result%20type%3A%20%7Btype(lazy_result)%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Key%20differences%3A%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20query()%3A%20Executes%20immediately%2C%20returns%20DataFrame%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20lazy_query()%3A%20Returns%20LazyQuery%20object%20for%20composition%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20lazy_query()%3A%20Can%20chain%20operations%20without%20materialization%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20lazy_query()%3A%20Only%20executes%20when%20.compute()%20is%20called%22)%0A%0A%20%20%20%20%20%20%20%20return%20immediate_result%2C%20lazy_result%0A%0A%20%20%20%20import%20time%0A%0A%20%20%20%20immediate_result%2C%20lazy_result%20%3D%20compare_query_vs_lazy_query()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%203.%20Convenience%20Methods%20-%20Easy%20Filtering%0A%0A%20%20%20%20SLAF%20provides%20convenient%20methods%20for%20common%20operations%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20%23%20Demonstrate%20convenience%20methods%0A%20%20%20%20print(%22%F0%9F%8E%AF%20Convenience%20Methods%22)%0A%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20%23%20Filter%20cells%0A%20%20%20%20print(%22%5Cn1.%20Filter%20cells%20by%20criteria%3A%22)%0A%0A%20%20%20%20%23%20High%20quality%20cells%0A%20%20%20%20high_quality%20%3D%20slaf.filter_cells(n_genes_by_counts%3D%22%3E%3D1000%22%2C%20total_counts%3D%22%3E%3D2000%22)%0A%20%20%20%20print(f%22%20%20%20High%20quality%20cells%20(%E2%89%A51000%20genes%2C%20%E2%89%A52000%20counts)%3A%20%7Blen(high_quality)%3A%2C%7D%22)%0A%0A%20%20%20%20%23%20Filter%20genes%0A%20%20%20%20print(%22%5Cn2.%20Filter%20genes%20by%20criteria%3A%22)%0A%0A%20%20%20%20%23%20Highly%20variable%20genes%0A%20%20%20%20hvg_genes%20%3D%20slaf.filter_genes(highly_variable%3DTrue)%0A%20%20%20%20print(f%22%20%20%20Highly%20variable%20genes%3A%20%7Blen(hvg_genes)%3A%2C%7D%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%204.%20Lazy%20AnnData%20Interface%20-%20Scanpy%20Compatible%0A%0A%20%20%20%20SLAF%20provides%20a%20lazy%20AnnData%20interface%20that's%20compatible%20with%20scanpy%20workflows%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf)%3A%0A%20%20%20%20%23%20Load%20as%20lazy%20AnnData%0A%20%20%20%20adata%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%E2%9C%85%20Loaded%20as%20LazyAnnData%3A%20%7Badata.shape%5B0%5D%3A%2C%7D%20cells%20%C3%97%20%7Badata.shape%5B1%5D%3A%2C%7D%20genes%22%0A%20%20%20%20)%0A%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(adata)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Expression%20matrix%20type%3A%20%7Btype(adata.X)%7D%22)%0A%20%20%20%20return%20(adata%2C)%0A%0A%0A%40app.cell%0Adef%20_(adata)%3A%0A%20%20%20%20%23%20Basic%20AnnData%20operations%0A%20%20%20%20print(%22%F0%9F%94%AC%20Basic%20AnnData%20Operations%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20print(f%22Dataset%20shape%3A%20%7Badata.shape%7D%22)%0A%20%20%20%20print(f%22Number%20of%20cells%3A%20%7Badata.n_obs%7D%22)%0A%20%20%20%20print(f%22Number%20of%20genes%3A%20%7Badata.n_vars%7D%22)%0A%0A%20%20%20%20%23%20Show%20available%20metadata%0A%20%20%20%20if%20hasattr(adata%2C%20%22obs%22)%20and%20adata.obs%20is%20not%20None%3A%0A%20%20%20%20%20%20%20%20print(f%22%5CnCell%20metadata%20columns%3A%20%7Blist(adata.obs.columns)%7D%22)%0A%0A%20%20%20%20if%20hasattr(adata%2C%20%22var%22)%20and%20adata.var%20is%20not%20None%3A%0A%20%20%20%20%20%20%20%20print(f%22Gene%20metadata%20columns%3A%20%7Blist(adata.var.columns)%7D%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata)%3A%0A%20%20%20%20%23%20Lazy%20slicing%20operations%0A%20%20%20%20print(%22%E2%9C%82%EF%B8%8F%20Lazy%20Slicing%20Operations%22)%0A%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20%23%20Slice%20cells%0A%20%20%20%20subset_cells%20%3D%20adata%5B%3A100%2C%20%3A%5D%0A%20%20%20%20print(f%22First%20100%20cells%20subset%3A%20%7Bsubset_cells.shape%7D%22)%0A%0A%20%20%20%20%23%20Slice%20genes%0A%20%20%20%20subset_genes%20%3D%20adata%5B%3A%2C%20%3A50%5D%0A%20%20%20%20print(f%22First%2050%20genes%20subset%3A%20%7Bsubset_genes.shape%7D%22)%0A%0A%20%20%20%20%23%20Combined%20slice%0A%20%20%20%20subset_both%20%3D%20adata%5B%3A50%2C%20%3A25%5D%0A%20%20%20%20print(f%2250%20cells%20%C3%97%2025%20genes%20subset%3A%20%7Bsubset_both.shape%7D%22)%0A%0A%20%20%20%20print(%22%5CnNote%3A%20These%20operations%20are%20lazy%20-%20no%20data%20is%20loaded%20until%20needed!%22)%0A%0A%20%20%20%20return%20(subset_cells%2C)%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%205.%20Lazy%20Scanpy%20Preprocessing%0A%0A%20%20%20%20SLAF%20provides%20lazy%20versions%20of%20scanpy%20preprocessing%20functions%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata%2C%20slaf_scanpy)%3A%0A%20%20%20%20%23%20Lazy%20scanpy%20preprocessing%0A%20%20%20%20print(%22%F0%9F%A7%AC%20Lazy%20Scanpy%20Preprocessing%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%23%20Calculate%20QC%20metrics%20(lazy)%0A%20%20%20%20print(%221.%20Calculating%20QC%20metrics...%22)%0A%20%20%20%20slaf_scanpy.pp.calculate_qc_metrics(adata%2C%20inplace%3DTrue)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20QC%20metrics%20calculated%20(lazily)%22)%0A%0A%20%20%20%20%23%20Filter%20cells%20(lazy)%0A%20%20%20%20print(%22%5Cn2.%20Filtering%20cells...%22)%0A%20%20%20%20slaf_scanpy.pp.filter_cells(adata%2C%20min_genes%3D200%2C%20inplace%3DTrue)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Cells%20filtered%20(lazily)%22)%0A%0A%20%20%20%20%23%20Filter%20genes%20(lazy)%0A%20%20%20%20print(%22%5Cn3.%20Filtering%20genes...%22)%0A%20%20%20%20slaf_scanpy.pp.filter_genes(adata%2C%20min_cells%3D30%2C%20inplace%3DTrue)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Genes%20filtered%20(lazily)%22)%0A%0A%20%20%20%20print(f%22%5CnFinal%20dataset%20shape%3A%20%7Badata.shape%5B0%5D%3A%2C%7D%20cells%20%C3%97%20%7Badata.shape%5B1%5D%3A%2C%7D%20genes%22)%0A%20%20%20%20print(%22Note%3A%20All%20operations%20are%20lazy%20-%20data%20is%20only%20processed%20when%20accessed!%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata%2C%20subset_cells)%3A%0A%20%20%20%20%23%20Demonstrate%20.compute()%20method%0A%20%20%20%20print(%22%E2%9A%A1%20Explicit%20Computation%20with%20.compute()%22)%0A%20%20%20%20print(%22%3D%22%20*%2040)%0A%0A%20%20%20%20print(%221.%20Computing%20full%20dataset%3A%22)%0A%20%20%20%20print(f%22%20%20%20Before%3A%20%7Btype(adata)%7D%22)%0A%20%20%20%20native_adata%20%3D%20adata.compute()%0A%20%20%20%20print(f%22%20%20%20After%3A%20%7Btype(native_adata)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bnative_adata.shape%7D%22)%0A%0A%20%20%20%20print(%22%5Cn2.%20Computing%20expression%20matrix%20only%3A%22)%0A%20%20%20%20print(f%22%20%20%20Before%3A%20%7Btype(adata.X)%7D%22)%0A%20%20%20%20sparse_matrix%20%3D%20adata.X.compute()%0A%20%20%20%20print(f%22%20%20%20After%3A%20%7Btype(sparse_matrix)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bsparse_matrix.shape%7D%22)%0A%0A%20%20%20%20print(%22%5Cn3.%20Computing%20sliced%20data%3A%22)%0A%20%20%20%20print(f%22%20%20%20Slice%20type%3A%20%7Btype(subset_cells)%7D%22)%0A%20%20%20%20native_slice%20%3D%20subset_cells.compute()%0A%20%20%20%20print(f%22%20%20%20Computed%20slice%20type%3A%20%7Btype(native_slice)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bnative_slice.shape%7D%22)%0A%0A%20%20%20%20print(%22%5CnKey%20insight%3A%20.compute()%20converts%20lazy%20objects%20to%20native%20scanpy%20objects!%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%206.%20Performance%20Characteristics%0A%0A%20%20%20%20Let's%20examine%20SLAF's%20performance%20characteristics%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(slaf)%3A%0A%20%20%20%20def%20examine_performance_characteristics()%3A%0A%20%20%20%20%20%20%20%20import%20time%0A%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A1%20Performance%20Characteristics%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%20%20%20%20%23%20Test%20cell%20filtering%20performance%0A%20%20%20%20%20%20%20%20print(%22%5Cn1.%20Cell%20filtering%20performance%3A%22)%0A%0A%20%20%20%20%20%20%20%20%23%20SLAF%20SQL%20approach%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20_%20%3D%20slaf.query(%22SELECT%20COUNT(*)%20FROM%20cells%20WHERE%20n_genes_by_counts%20%3E%20500%22)%0A%20%20%20%20%20%20%20%20slaf_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20SLAF%20SQL%3A%20%7Bslaf_time%3A.4f%7Ds%22)%0A%0A%20%20%20%20%20%20%20%20%23%20SLAF%20convenience%20method%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20_%20%3D%20slaf.filter_cells(n_genes_by_counts%3D%22%3E500%22)%0A%20%20%20%20%20%20%20%20slaf_filter_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20SLAF%20filter%20method%3A%20%7Bslaf_filter_time%3A.4f%7Ds%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Test%20expression%20aggregation%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Expression%20aggregation%20performance%3A%22)%0A%0A%20%20%20%20%20%20%20%20%23%20SLAF%20SQL%20aggregation%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20_%20%3D%20slaf.query(%22SELECT%20AVG(value)%20FROM%20expression%22)%0A%20%20%20%20%20%20%20%20slaf_agg_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20SLAF%20SQL%20aggregation%3A%20%7Bslaf_agg_time%3A.4f%7Ds%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Lazy%20AnnData%20approach%20(when%20computed)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20Lazy%20AnnData%3A%20Operations%20stored%2C%20computed%20on%20demand%22)%0A%0A%20%20%20%20examine_performance_characteristics()%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%208.%20Quick%20Tokenization%20Example%0A%0A%20%20%20%20SLAF%20provides%20efficient%20tokenization%20for%20ML%20training%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(np%2C%20slaf)%3A%0A%20%20%20%20%23%20Quick%20tokenization%20example%0A%20%20%20%20from%20slaf.ml.tokenizers%20import%20SLAFTokenizer%0A%0A%20%20%20%20print(%22%F0%9F%8E%AF%20Quick%20Tokenization%20Example%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%23%20Initialize%20tokenizer%0A%20%20%20%20tokenizer%20%3D%20SLAFTokenizer(slaf%2C%20vocab_size%3D1000%2C%20n_expression_bins%3D10)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%E2%9C%85%20Tokenizer%20initialized%20with%20%7Btokenizer.get_vocab_info()%5B'total_vocab_size'%5D%7D%20total%20tokens%22%0A%20%20%20%20)%0A%0A%20%20%20%20%23%20Get%20a%20small%20batch%20of%20cells%0A%0A%20%20%20%20%23%20Tokenize%20for%20Geneformer%0A%20%20%20%20print(%22%5Cn1.%20Geneformer%20tokenization%3A%22)%0A%20%20%20%20geneformer_tokens%20%3D%20tokenizer.tokenize_geneformer((0%2C%2032)%2C%20max_genes%3D100)%0A%20%20%20%20print(f%22%20%20%20Generated%20%7Blen(geneformer_tokens)%7D%20token%20sequences%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Average%20sequence%20length%3A%20%7Bint(np.mean(%5Blen(seq)%20for%20seq%20in%20geneformer_tokens%5D))%3Ad%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20%23%20Tokenize%20for%20scGPT%0A%20%20%20%20print(%22%5Cn2.%20scGPT%20tokenization%3A%22)%0A%20%20%20%20scgpt_tokens%20%3D%20tokenizer.tokenize_scgpt((0%2C%2032)%2C%20max_genes%3D100)%0A%20%20%20%20print(f%22%20%20%20Generated%20%7Blen(scgpt_tokens)%7D%20token%20sequences%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Average%20sequence%20length%3A%20%7Bint(np.mean(%5Blen(seq)%20for%20seq%20in%20scgpt_tokens%5D))%3Ad%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%20Summary%0A%0A%20%20%20%20%20%20%20%20**What%20you've%20learned%3A**%0A%0A%20%20%20%201.%20**SQL%20Schema**%3A%20SLAF%20stores%20data%20in%203%20tables%20(cells%2C%20genes%2C%20expression)%20that%20you%20can%20query%20directly%0A%20%20%20%202.%20**SQL%20Power**%3A%20Direct%20SQL%20access%20for%20complex%20queries%20and%20aggregations%0A%20%20%20%203.%20**Lazy%20Queries**%3A%20Use%20%60lazy_query()%60%20for%20composable%20SQL%20operations%20that%20build%20step%20by%20step%0A%20%20%20%204.%20**Convenience%20Methods**%3A%20Easy%20filtering%20with%20%60filter_cells()%60%20and%20%60filter_genes()%60%0A%20%20%20%205.%20**Lazy%20AnnData**%3A%20Scanpy-compatible%20interface%20with%20lazy%20evaluation%0A%20%20%20%206.%20**Lazy%20Preprocessing**%3A%20scanpy%20functions%20that%20work%20lazily%0A%20%20%20%207.%20**Performance**%3A%20SQL-level%20performance%20for%20data%20operations%0A%20%20%20%208.%20**Explicit%20Computation**%3A%20Use%20%60.compute()%60%20to%20convert%20lazy%20objects%20to%20native%20Python%20objects%0A%20%20%20%209.%20**Tokenization**%3A%20Ready%20for%20ML%20training%20with%20efficient%20tokenization%0A%0A%20%20%20%20**Next%20Steps%3A**%0A%0A%20%20%20%20-%20**02-lazy-processing.py**%3A%20Deep%20dive%20into%20lazy%20evaluation%20capabilities%0A%0A%20%20%20%20-%20**03-ml-training-pipeline.py**%3A%20Complete%20ML%20training%20workflows%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20app.run()%0A
</marimo-code>

<marimo-code-hash hidden="">5ee7e30c3e024b65e014c620d7e1fc5f5bc9a9c5d74d599073c84d3128aebd28</marimo-code-hash>
</body>
</html>
