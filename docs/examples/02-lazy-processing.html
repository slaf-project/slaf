<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/favicon.ico" />
    <!-- Preload is necessary because we show these images when we disconnect from the server,
    but at that point we cannot load these images from the server -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/gradient-yHQUC_QB.png" as="image" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/noise-60BoTA8O.png" as="image" />
    <!-- Preload the fonts -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/Lora-VariableFont_wght-B2ootaw-.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/PTSans-Regular-CxL0S8W7.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/PTSans-Bold-D9fedIX3.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Regular-BTCkDNvf.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Medium-DU3aDxX5.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/FiraMono-Bold-CLVRCuM9.ttf" as="font" crossorigin="anonymous" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="a marimo app" />
    <link rel="apple-touch-icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/apple-touch-icon.png" />
    <link rel="manifest" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/manifest.json" />

    <script data-marimo="true">
      function __resizeIframe(obj) {
        var scrollbarHeight = 20; // Max between windows, mac, and linux

        function setHeight() {
          var element = obj.contentWindow.document.documentElement;
          // If there is no vertical scrollbar, we don't need to resize the iframe
          if (element.scrollHeight === element.clientHeight) {
            return;
          }

          // Create a new height that includes the scrollbar height if it's visible
          var hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
          var newHeight = element.scrollHeight + (hasHorizontalScrollbar ? scrollbarHeight : 0);

          // Only update the height if it's different from the current height
          if (obj.style.height !== `${newHeight}px`) {
            obj.style.height = `${newHeight}px`;
          }
        }

        // Resize the iframe to the height of the content and bottom scrollbar height
        setHeight();

        // Resize the iframe when the content changes
        const resizeObserver = new ResizeObserver((entries) => {
          setHeight();
        });
        resizeObserver.observe(obj.contentWindow.document.body);
      }
    </script>
    <marimo-filename hidden>02-lazy-processing.py</marimo-filename>
    <title>02-lazy-processing</title>
    <script type="module" crossorigin crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/index-_Zd2Tjcq.js"></script>
    <link rel="stylesheet" crossorigin crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.14.0/dist/assets/index-BVt8Dtzn.css">

<script data-marimo="true">
    window.__MARIMO_STATIC__ = {};
    window.__MARIMO_STATIC__.files = {};
</script>
</head>
  <body>
    <div id="root"></div>
    <script data-marimo="true">
      window.__MARIMO_MOUNT_CONFIG__ = {
            "filename": "02-lazy-processing.py",
            "mode": "read",
            "version": "0.14.0",
            "serverToken": "static",
            "config": {"completion": {"activate_on_typing": true, "copilot": false}, "display": {"cell_output": "above", "code_editor_font_size": 14, "dataframes": "rich", "default_table_page_size": 10, "default_width": "medium", "theme": "light"}, "formatting": {"line_length": 79}, "keymap": {"overrides": {}, "preset": "default"}, "language_servers": {"pylsp": {"enable_flake8": false, "enable_mypy": true, "enable_pydocstyle": false, "enable_pyflakes": false, "enable_pylint": false, "enable_ruff": true, "enabled": true}}, "package_management": {"manager": "pip"}, "runtime": {"auto_instantiate": true, "auto_reload": "off", "default_sql_output": "auto", "on_cell_change": "autorun", "output_max_bytes": 8000000, "reactive_tests": true, "std_stream_max_bytes": 1000000, "watcher_on_save": "lazy"}, "save": {"autosave": "after_delay", "autosave_delay": 1000, "format_on_save": false}, "server": {"browser": "default", "follow_symlink": false}, "snippets": {"custom_paths": [], "include_default_snippets": true}},
            "configOverrides": {},
            "appConfig": {"sql_output": "auto", "width": "medium"},
            "view": {"showAppCode": true},
            "notebook": {"cells": [{"code": "import time\n\nimport marimo as mo\n\nfrom slaf.integrations import scanpy as slaf_scanpy\nfrom slaf.integrations.anndata import read_slaf\n", "code_hash": "ee831f7ecafcfd8bc85eb1345cea6f79", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Hbol", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n# SLAF Lazy Processing Deep Dive\n\nThis notebook explores SLAF's lazy evaluation capabilities in detail. You'll learn how to:\n\n- Build complex analysis pipelines without loading data\n- Apply multiple transformations efficiently\n- Use different slicing patterns\n- Control when computation happens\n- Understand performance benefits\n\n**Key Concept**: Lazy evaluation means operations are stored as instructions and only executed when you explicitly request the results.\n\n**Key Benefits:**\n- \ud83d\ude80 **Instant Pipeline Building**: No waiting for data loading\n- \ud83d\udcbe **Memory Efficient**: Only load what you need\n- \ud83d\udd04 **Composable**: Operations can be combined and preserved\n- \u26a1 **SQL Performance**: Leverage database-level optimizations\n- \ud83e\uddec **Scanpy Compatible**: Familiar interface with performance benefits\n\"\"\"\n)", "code_hash": "6377adf053e9550184c48dd346df4127", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "MJUe", "name": "_"}, {"code": "# Load data for lazy processing examples\nadata = read_slaf(\"../slaf-datasets/pbmc3k_processed.slaf\")\nprint(f\"\u2705 Loaded dataset: {adata.shape[0]:,} cells \u00d7 {adata.shape[1]:,} genes\")\nprint(f\"   Type: {type(adata)}\")\nprint(f\"   Expression matrix type: {type(adata.X)}\")", "code_hash": "1b3a67a5f4de2dd7e33027b6ffe747db", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "vblA", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 1. Understanding Lazy Objects\n\nSLAF provides two main lazy object types:\n\n- **LazyAnnData**: Lazy version of AnnData with scanpy compatibility\n\n- **LazyExpressionMatrix**: Lazy version of the expression matrix\n\"\"\"\n)", "code_hash": "75f5c8abad0ffa3e12f1e8ea9d969ccd", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "bkHC", "name": "_"}, {"code": "# Demonstrate lazy object types\nprint(\"\ud83d\udd0d Lazy Object Types\")\nprint(\"=\" * 30)\n\nprint(f\"1. LazyAnnData type: {type(adata)}\")\nprint(f\"   - Shape: {adata.shape}\")\nprint(\n    f\"   - Obs columns: {list(adata.obs.columns) if hasattr(adata, 'obs') and adata.obs is not None else 'Not loaded'}\"\n)\nprint(\n    f\"   - Var columns: {list(adata.var.columns) if hasattr(adata, 'var') and adata.var is not None else 'Not loaded'}\"\n)\n\nprint(f\"\\n2. LazyExpressionMatrix type: {type(adata.X)}\")\nprint(f\"   - Shape: {adata.X.shape}\")\nprint(\n    f\"   - Parent: {type(adata.X.parent_adata) if hasattr(adata.X, 'parent_adata') else 'None'}\"\n)\n\nprint(\"\\n3. Key insight: These objects store operations, not data!\")\nprint(\"   - No data is loaded until you call .compute()\")\nprint(\"   - Operations are composed efficiently\")\nprint(\"   - Memory usage stays low\")\n", "code_hash": "27abcbd6b6eafac1082f02ff3d9342f2", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "lEQa", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 2. Explicit Computation Control\n\nYou control when data is actually computed using these methods:\n\"\"\"\n)", "code_hash": "a5cb9b5af5e969c286ca73720febe56e", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "PKri", "name": "_"}, {"code": "def demonstrate_computation_control():\n    # Demonstrate explicit computation control\n    print(\"\ud83c\udf9b\ufe0f Explicit Computation Control\")\n    print(\"=\" * 35)\n\n    print(\"Available computation methods:\")\n    print(\"1. adata.compute() \u2192 native AnnData object\")\n    print(\"2. adata.X.compute() \u2192 scipy.sparse.csr_matrix\")\n    print(\"3. adata.obs \u2192 pandas.DataFrame (cell metadata)\")\n    print(\"4. adata.var \u2192 pandas.DataFrame (gene metadata)\")\n\n    print(\"\\nLet's demonstrate:\")\n\n    # Compute just the expression matrix\n    print(\"\\n1. Computing expression matrix...\")\n    start_time = time.time()\n    sparse_matrix = adata.X.compute()\n    compute_time = time.time() - start_time\n    print(f\"   \u2705 Computed in {compute_time:.4f}s\")\n    print(f\"   Type: {type(sparse_matrix)}\")\n    print(f\"   Shape: {sparse_matrix.shape}\")\n    print(f\"   Memory: {sparse_matrix.data.nbytes / 1024 / 1024:.1f} MB\")\n\n    # Access cell metadata\n    print(\"\\n2. Accessing cell metadata...\")\n    start_time = time.time()\n    obs_df = adata.obs\n    obs_time = time.time() - start_time\n    print(f\"   \u2705 Accessed in {obs_time:.4f}s\")\n    print(f\"   Type: {type(obs_df)}\")\n    print(f\"   Shape: {obs_df.shape}\")\n\n    return (sparse_matrix, obs_df)\n\nsparse_matrix, obs_df = demonstrate_computation_control()", "code_hash": "5b178fc99a1c074c19665d89a06f9f4c", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Xref", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 3. Slicing Patterns - All the Ways to Slice\n\nSLAF supports multiple slicing patterns, all of which are lazy:\n\"\"\"\n)", "code_hash": "c63d9fc9f55bad77978773a461777efa", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "SFPL", "name": "_"}, {"code": "# Demonstrate different slicing patterns\ndef demonstrate_slicing_patterns(adata):\n    print(\"\u2702\ufe0f Slicing Patterns\")\n    print(\"=\" * 25)\n\n    print(\"1. Basic integer slicing:\")\n    slice1 = adata[:100, :50]\n    print(f\"   adata[:100, :50] \u2192 {type(slice1)} with shape {slice1.shape}\")\n\n    print(\"\\n2. Expression matrix slicing:\")\n    slice2 = adata.X[:100, :50]\n    print(f\"   adata.X[:100, :50] \u2192 {type(slice2)} with shape {slice2.shape}\")\n\n    print(\"\\n3. Boolean indexing (after QC metrics are available):\")\n    # First add some QC metrics\n    if (\n        hasattr(adata, \"obs\")\n        and adata.obs is not None\n        and \"n_genes_by_counts\" in adata.obs.columns\n    ):\n        high_quality_mask = adata.obs[\"n_genes_by_counts\"] > 1000\n        slice3 = adata[high_quality_mask, :]\n        print(\n            f\"   adata[high_quality_mask, :] \u2192 {type(slice3)} with shape {slice3.shape}\"\n        )\n    else:\n        print(\n            \"   (QC metrics not available yet - will be computed in preprocessing section)\"\n        )\n\n    print(\"\\n4. Mixed indexing:\")\n    slice4 = adata[:100, adata.var.index[:50]]\n    print(\n        f\"   adata[:100, adata.var.index[:50]] \u2192 {type(slice4)} with shape {slice4.shape}\"\n    )\n\n    print(\"\\nKey insight: All slicing returns lazy objects!\")\n\ndemonstrate_slicing_patterns(adata)", "code_hash": "199d1d90390bd28f946f91839a475656", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "BYtC", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 4. Transformation Patterns\n\nSLAF supports lazy transformations that are stored and applied when needed:\n\"\"\"\n)", "code_hash": "8dcce7dd085aa1c193e37db381119a96", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "RGSE", "name": "_"}, {"code": "# Load fresh data for transformation examples\nadata_fresh = read_slaf(\"../slaf-datasets/pbmc3k_processed.slaf\")\nprint(\"\u2705 Loaded fresh dataset for transformations\")", "code_hash": "dab326a7d7603e0f09f85c86171ff8aa", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Kclp", "name": "_"}, {"code": "# Demonstrate transformation patterns\nprint(\"\ud83d\udd04 Transformation Patterns\")\nprint(\"=\" * 30)\n\nprint(\"1. Single transformation:\")\nadata_norm = slaf_scanpy.pp.normalize_total(\n    adata_fresh, target_sum=1e4, inplace=False\n)\nprint(f\"   normalize_total() \u2192 {type(adata_norm)}\")\nprint(\n    f\"   Transformations stored: {list(adata_norm._transformations.keys()) if hasattr(adata_norm, '_transformations') else 'None'}\"\n)\n\nprint(\"\\n2. Chained transformations:\")\nadata_processed = slaf_scanpy.pp.normalize_total(\n    adata_fresh, target_sum=1e4, inplace=False\n)\nadata_processed = slaf_scanpy.pp.log1p(adata_processed, inplace=False)\nprint(f\"   normalize_total().log1p() \u2192 {type(adata_processed)}\")\nprint(\n    f\"   Transformations stored: {list(adata_processed._transformations.keys()) if hasattr(adata_processed, '_transformations') else 'None'}\"\n)\n\nprint(\"\\n3. Transformation on sliced data:\")\n# First slice, then apply transformation (safer pattern)\nslice_data = adata_fresh[:100, :50]\nslice_transformed = slaf_scanpy.pp.normalize_total(\n    slice_data, target_sum=1e4, inplace=False\n)\nprint(f\"   adata[:100, :50].normalize_total() \u2192 {type(slice_transformed)}\")\nprint(f\"   Shape: {slice_transformed.shape}\")\n\nprint(\"\\n4. Multiple transformations on slice:\")\n# First slice, then apply transformations (safer pattern)\nslice_data = adata_fresh[:100, :50]\nslice_multi = slaf_scanpy.pp.normalize_total(\n    slice_data, target_sum=1e4, inplace=False\n)\nslice_multi = slaf_scanpy.pp.log1p(slice_multi, inplace=False)\nprint(f\"   Multiple transformations on slice \u2192 {type(slice_multi)}\")\nprint(\n    f\"   Transformations: {list(slice_multi._transformations.keys()) if hasattr(slice_multi, '_transformations') else 'None'}\"\n)\n", "code_hash": "78614dd4b31d97af81dedb11eb4af53f", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "emfo", "name": "_"}, {"code": "def demonstrate_transformation_application():\n    # Demonstrate transformation application\n    print(\"\u26a1 Applying Transformations\")\n    print(\"=\" * 30)\n\n    print(\"1. Computing transformed data:\")\n    start_time = time.time()\n    native_processed = adata_processed.compute()\n    process_time = time.time() - start_time\n    print(f\"   \u2705 Computed in {process_time:.4f}s\")\n    print(f\"   Type: {type(native_processed)}\")\n    print(f\"   Shape: {native_processed.shape}\")\n\n    print(\"\\n2. Computing transformed slice:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    native_slice_matrix = slice_transformed.X.compute()\n    slice_time = time.time() - start_time\n    print(f\"   \u2705 Computed in {slice_time:.4f}s\")\n    print(f\"   Type: {type(native_slice_matrix)}\")\n    print(f\"   Shape: {native_slice_matrix.shape}\")\n\n    print(\"\\n3. Computing multi-transformed slice:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    native_multi_matrix = slice_multi.X.compute()\n    multi_time = time.time() - start_time\n    print(f\"   \u2705 Computed in {multi_time:.4f}s\")\n    print(f\"   Type: {type(native_multi_matrix)}\")\n    print(f\"   Shape: {native_multi_matrix.shape}\")\n\n    return (native_processed, native_slice_matrix, native_multi_matrix)\n\ndemonstrate_transformation_application()", "code_hash": "62e478d2b023db6c22f2b1be709a793e", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Hstk", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 5. Transformation Preservation Through Operations\n\nTransformations are preserved through slicing and other operations:\n\"\"\"\n)", "code_hash": "31cc1e49d33335690bedb214b1570f4d", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "nWHF", "name": "_"}, {"code": "# Load fresh data for preservation examples\nadata_preserve = read_slaf(\"../slaf-datasets/pbmc3k.slaf\")", "code_hash": "9f46c11315ca9c36ae8db9e93d02530b", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "iLit", "name": "_"}, {"code": "# Demonstrate transformation preservation\nprint(\"\ud83d\udd04 Transformation Preservation\")\nprint(\"=\" * 35)\n\nprint(\"1. Apply transformations first, then slice:\")\nadata_transformed = slaf_scanpy.pp.normalize_total(\n    adata_preserve, target_sum=1e4, inplace=False\n)\nadata_transformed = slaf_scanpy.pp.log1p(adata_transformed, inplace=False)\nslice_after = adata_transformed[:100, :50]\nprint(\n    f\"   Original transformations: {list(adata_transformed._transformations.keys()) if hasattr(adata_transformed, '_transformations') else 'None'}\"\n)\nprint(\n    f\"   Slice transformations: {list(slice_after._transformations.keys()) if hasattr(slice_after, '_transformations') else 'None'}\"\n)\n\nprint(\"\\n2. Slice first, then apply transformations:\")\nslice_before = adata_preserve[:100, :50]\ntransformed_slice = slaf_scanpy.pp.normalize_total(\n    slice_before, target_sum=1e4, inplace=False\n)\ntransformed_slice = slaf_scanpy.pp.log1p(transformed_slice, inplace=False)\nprint(f\"   Transformed slice: {type(transformed_slice)}\")\nprint(\n    f\"   Transformations: {list(transformed_slice._transformations.keys()) if hasattr(transformed_slice, '_transformations') else 'None'}\"\n)\n\nprint(\"\\n3. Complex slicing patterns preserve transformations:\")\nprint(\n    \"   Note: Chained slicing (e.g., adata[:200, :100][:50, :25]) is not supported.\"\n)\nprint(\"   Use single-step slicing instead: adata[50:250, 25:125]\")\n\n# Single-step slicing (equivalent to nested slicing)\nsingle_step_slice = adata_transformed[50:250, 25:125]\nprint(f\"   Single-step slice: {type(single_step_slice)}\")\nprint(\n    f\"   Transformations preserved: {list(single_step_slice._transformations.keys()) if hasattr(single_step_slice, '_transformations') else 'None'}\"\n)\n\n# Boolean mask slicing\nimport numpy as np\n\ncell_mask = np.zeros(adata_transformed.shape[0], dtype=bool)\ncell_mask[50:250] = True\ngene_mask = np.zeros(adata_transformed.shape[1], dtype=bool)\ngene_mask[25:125] = True\nboolean_slice = adata_transformed[cell_mask, gene_mask]\nprint(f\"   Boolean mask slice: {type(boolean_slice)}\")\nprint(\n    f\"   Transformations preserved: {list(boolean_slice._transformations.keys()) if hasattr(boolean_slice, '_transformations') else 'None'}\"\n)\n\n# Step slicing\nstep_slice = adata_transformed[::4, ::2]  # Every 4th cell, every 2nd gene\nprint(f\"   Step slice: {type(step_slice)}\")\nprint(\n    f\"   Transformations preserved: {list(step_slice._transformations.keys()) if hasattr(step_slice, '_transformations') else 'None'}\"\n)\n", "code_hash": "6f443d1465f728c5930dad9639ce3e4d", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ZHCJ", "name": "_"}, {"code": "def verify_transformation_preservation():\n    # Verify transformation preservation by computing\n    print(\"\u2705 Verifying Transformation Preservation\")\n    print(\"=\" * 40)\n\n    print(\"1. Computing slice with preserved transformations:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    result1 = slice_after.X.compute()\n    time1 = time.time() - start_time\n    print(f\"   \u2705 Computed in {time1:.4f}s\")\n    print(f\"   Type: {type(result1)}\")\n    print(f\"   Shape: {result1.shape}\")\n\n    print(\"\\n2. Computing slice with applied transformations:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    result2 = transformed_slice.X.compute()\n    time2 = time.time() - start_time\n    print(f\"   \u2705 Computed in {time2:.4f}s\")\n    print(f\"   Type: {type(result2)}\")\n    print(f\"   Shape: {result2.shape}\")\n\n    print(\"\\n3. Computing single-step slice with preserved transformations:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    result3 = single_step_slice.X.compute()\n    time3 = time.time() - start_time\n    print(f\"   \u2705 Computed in {time3:.4f}s\")\n    print(f\"   Type: {type(result3)}\")\n    print(f\"   Shape: {result3.shape}\")\n\nverify_transformation_preservation()\n", "code_hash": "ffeb2a68524b726c24b91f62a943ef0f", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ROlb", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 6. Performance Benefits - Building Complex Pipelines\n\nLet's see how lazy evaluation enables efficient complex pipelines:\n\"\"\"\n)", "code_hash": "87bb153b5d40e6bd9067b2faef2f8e30", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "qnkX", "name": "_"}, {"code": "# Demonstrate performance benefits\n\ndef demonstrate_complex_pipeline(adata):\n    print(\"\u26a1 Performance Benefits\")\n    print(\"=\" * 25)\n\n    print(\"1. Building complex pipeline (no computation yet):\")\n    start_time = time.time()\n\n    # Build a complex pipeline\n    pipeline = slaf_scanpy.pp.normalize_total(adata, target_sum=1e4, inplace=False)\n    pipeline = slaf_scanpy.pp.log1p(pipeline, inplace=False)\n\n    # Note: highly_variable_genes returns a DataFrame, not a LazyAnnData object\n    # so it can't be chained in the pipeline like other transformations\n\n    # Slice the processed data\n    final_slice = pipeline[:500, :200]\n\n    build_time = time.time() - start_time\n    print(f\"   \u2705 Pipeline built in {build_time:.4f}s\")\n    print(f\"   Final object: {type(final_slice)}\")\n    print(\n        \"   Expected shape: (500, 200)\"\n    )  # Avoid accessing .shape on transformed slice\n    print(\n        f\"   Transformations: {list(final_slice._transformations.keys()) if hasattr(final_slice, '_transformations') else 'None'}\"\n    )\n\n    print(\"\\n2. Computing the final result:\")\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    final_result = final_slice.X.compute()\n    compute_time = time.time() - start_time\n    print(f\"   \u2705 Computed in {compute_time:.4f}s\")\n    print(f\"   Type: {type(final_result)}\")\n    print(f\"   Shape: {final_result.shape}\")\n\n    print(f\"\\n3. Total time: {build_time + compute_time:.4f}s\")\n    print(\n        \"   Key insight: Pipeline building is instant, computation happens only when needed!\"\n    )\n\ndemonstrate_complex_pipeline(adata)", "code_hash": "3b710cc181d374a19352beaef1e67062", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "TqIu", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 7. Memory Efficiency Comparison\n\nLet's compare memory usage between lazy and eager approaches:\n\"\"\"\n)", "code_hash": "7f9fa546b1b9f8744da767eb2af75d33", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Vxnm", "name": "_"}, {"code": "# Memory efficiency comparison\nprint(\"\ud83d\udcbe Memory Efficiency Comparison\")\nprint(\"=\" * 35)\n\nimport gc\n\nimport psutil\n\ndef get_memory_usage():\n    \"\"\"Get current memory usage in MB\"\"\"\n    process = psutil.Process()\n    return process.memory_info().rss / 1024 / 1024\n\n# Load fresh data\nadata_mem = read_slaf(\"../slaf-datasets/pbmc3k_processed.slaf\")\n\nprint(\"1. Memory after loading lazy data:\")\ngc.collect()\nlazy_memory = get_memory_usage()\nprint(f\"   Lazy loading: {lazy_memory:.1f} MB\")\n\nprint(\"\\n2. Memory after computing full dataset:\")\ngc.collect()\nstart_memory = get_memory_usage()\n_ = adata_mem.compute()\nend_memory = get_memory_usage()\nprint(f\"   Eager loading: {end_memory:.1f} MB\")\nprint(f\"   Memory increase: {end_memory - start_memory:.1f} MB\")\n\nprint(\"\\n3. Memory after computing small slice:\")\ngc.collect()\nslice_memory_before = get_memory_usage()\n_ = adata_mem[:100, :50].compute()\nslice_memory_after = get_memory_usage()\nprint(f\"   Small slice: {slice_memory_after:.1f} MB\")\nprint(f\"   Memory increase: {slice_memory_after - slice_memory_before:.1f} MB\")\n\nprint(\n    f\"\\nKey insight: Lazy loading uses {lazy_memory:.1f} MB vs eager loading {end_memory:.1f} MB\"\n)\nprint(f\"Memory savings: {((end_memory - lazy_memory) / end_memory * 100):.1f}%\")\n", "code_hash": "6dfba50f4f01f8ecfececf41d0630ae3", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "DnEU", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 8. Advanced Slicing Patterns\n\nLet's explore more advanced slicing patterns:\n\"\"\"\n)", "code_hash": "c7949aa9588890c8628bbf631d148263", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ulZA", "name": "_"}, {"code": "# Advanced slicing patterns\nprint(\"\ud83d\udd2c Advanced Slicing Patterns\")\nprint(\"=\" * 35)\n\n# Load data and add QC metrics\nadata_advanced = read_slaf(\"../slaf-datasets/pbmc3k_processed.slaf\")\nslaf_scanpy.pp.calculate_qc_metrics(adata_advanced, inplace=True)\n\nprint(\"1. Boolean indexing with QC metrics:\")\nhigh_quality_mask = adata_advanced.obs[\"n_genes_by_counts\"] > 1000\nhigh_quality_cells = adata_advanced[high_quality_mask, :]\nprint(f\"   High quality cells: {high_quality_cells.shape}\")\n\nprint(\"\\n2. Gene-based filtering:\")\nif (\n    hasattr(adata_advanced, \"var\")\n    and adata_advanced.var is not None\n    and \"highly_variable\" in adata_advanced.var.columns\n):\n    hvg_mask = adata_advanced.var[\"highly_variable\"]\n    hvg_genes = adata_advanced[:, hvg_mask]\n    print(f\"   Highly variable genes: {hvg_genes.shape}\")\nelse:\n    print(\"   (Highly variable genes not available yet)\")\n\nprint(\"\\n3. Combined cell and gene filtering:\")\ncombined = adata_advanced[high_quality_mask, :100]\nprint(f\"   Combined filtering: {combined.shape}\")\n\nprint(\"\\n4. Expression-based filtering:\")\n# Get cells with high total counts\nhigh_counts_mask = adata_advanced.obs[\"total_counts\"] > 2000\nhigh_counts_cells = adata_advanced[high_counts_mask, :]\nprint(f\"   High count cells: {high_counts_cells.shape}\")\n", "code_hash": "9c331d9780819a8c1c3c08537ac2504c", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ecfG", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 9. Lazy vs Eager Performance Comparison\n\nLet's compare the performance of lazy vs eager approaches:\n\"\"\"\n)", "code_hash": "e44442767b8873d3214ad6e019ecdce0", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Pvdt", "name": "_"}, {"code": "# Performance comparison\ndef compare_lazy_vs_eager_performance(adata):\n    print(\"\u26a1 Lazy vs Eager Performance\")\n    print(\"=\" * 35)\n\n    # Test scenario: Apply transformations and slice\n    print(\"Scenario: normalize_total \u2192 log1p \u2192 slice[:100, :50]\")\n\n    # Lazy approach\n    print(\"\\n1. Lazy approach:\")\n    adata_lazy = adata\n\n    start_time = time.time()\n    lazy_pipeline = slaf_scanpy.pp.normalize_total(\n        adata_lazy, target_sum=1e4, inplace=False\n    )\n    lazy_pipeline = slaf_scanpy.pp.log1p(lazy_pipeline, inplace=False)\n    lazy_slice = lazy_pipeline[:100, :50]\n    lazy_build_time = time.time() - start_time\n\n    start_time = time.time()\n    # Use .X.compute() to avoid the metadata mismatch issue\n    _ = lazy_slice.X.compute()\n    lazy_compute_time = time.time() - start_time\n\n    print(f\"   Build time: {lazy_build_time:.4f}s\")\n    print(f\"   Compute time: {lazy_compute_time:.4f}s\")\n    print(f\"   Total time: {lazy_build_time + lazy_compute_time:.4f}s\")\n\n    # Eager approach (simulated)\n    print(\"\\n2. Eager approach (simulated):\")\n\n    start_time = time.time()\n    _ = adata.compute()\n    eager_load_time = time.time() - start_time\n\n    # Simulate eager transformations (this would be done in memory)\n    print(f\"   Load time: {eager_load_time:.4f}s\")\n    print(\"   Transformations would be done in memory (slower for large datasets)\")\n\n    print(\"\\n3. Key benefits:\")\n    print(\"   - Lazy: Build complex pipelines instantly\")\n    print(\"   - Lazy: Only compute what you need\")\n    print(\"   - Lazy: Memory efficient\")\n    print(\"   - Lazy: SQL-level performance for operations\")\n\ncompare_lazy_vs_eager_performance(adata)", "code_hash": "9f270672f0d74f498325e648828e5372", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "ZBYS", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## 10. Best Practices and Tips\n\nHere are some best practices for using SLAF's lazy evaluation:\n\"\"\"\n)", "code_hash": "8c92a9bf3966af0721a5b557dc7b5265", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "aLJB", "name": "_"}, {"code": "# Best practices\nprint(\"\ud83d\udca1 Best Practices and Tips\")\nprint(\"=\" * 30)\n\nprint(\"1. Pipeline Building:\")\nprint(\"   \u2705 Build complete pipelines before computing\")\nprint(\"   \u2705 Chain transformations: adata.normalize_total().log1p()\")\nprint(\"   \u2705 Slice after transformations for efficiency\")\n\nprint(\"\\n2. Computation Control:\")\nprint(\"   \u2705 Use .compute() only when you need the data\")\nprint(\"   \u2705 Use .obs or .var for metadata\")\nprint(\"   \u2705 Use .X.compute() for expression matrix only\")\n\nprint(\"\\n3. Memory Management:\")\nprint(\"   \u2705 Keep lazy objects for intermediate results\")\nprint(\"   \u2705 Compute only final results\")\nprint(\"   \u2705 Use slicing to reduce memory usage\")\n\nprint(\"\\n4. Performance Optimization:\")\nprint(\"   \u2705 Leverage SQL-level operations\")\nprint(\"   \u2705 Use boolean indexing for filtering\")\nprint(\"   \u2705 Combine operations in single queries when possible\")\n\nprint(\"\\n5. Debugging:\")\nprint(\"   \u2705 Check object types: type(adata)\")\nprint(\"   \u2705 Check transformations: adata._transformations\")\nprint(\"   \u2705 Use .info() for dataset overview\")\n", "code_hash": "145f0f83a2c3089b289fadf25ecaac34", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "nHfw", "name": "_"}, {"code": "mo.md(\n    \"\"\"\n## Summary\n\n**What you've learned about SLAF's lazy processing:**\n\n1. **Lazy Objects**: LazyAnnData and LazyExpressionMatrix store operations, not data\n2. **Explicit Control**: Use .compute() methods to control when data is processed\n3. **Slicing Patterns**: Multiple slicing patterns, all lazy and composable\n4. **Transformations**: Lazy transformations that are preserved through operations\n5. **Performance**: Build complex pipelines instantly, compute only when needed\n6. **Memory Efficiency**: Significant memory savings compared to eager loading\n7. **Best Practices**: Guidelines for optimal lazy evaluation usage\n\n**Next Steps:**\n- **03-ml-training-pipeline.py**: Complete ML training workflows with tokenizers and dataloaders\n\"\"\"\n)", "code_hash": "062b13d12cd10691103759404482ba25", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "xXTn", "name": "_"}], "metadata": {"marimo_version": "0.14.0"}, "version": "1"},
            "session": {"cells": [{"code_hash": "ee831f7ecafcfd8bc85eb1345cea6f79", "console": [], "id": "Hbol", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "6377adf053e9550184c48dd346df4127", "console": [], "id": "MJUe", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h1 id=\"slaf-lazy-processing-deep-dive\">SLAF Lazy Processing Deep Dive</h1>\n<span class=\"paragraph\">This notebook explores SLAF's lazy evaluation capabilities in detail. You'll learn how to:</span>\n<ul>\n<li>Build complex analysis pipelines without loading data</li>\n<li>Apply multiple transformations efficiently</li>\n<li>Use different slicing patterns</li>\n<li>Control when computation happens</li>\n<li>Understand performance benefits</li>\n</ul>\n<span class=\"paragraph\"><strong>Key Concept</strong>: Lazy evaluation means operations are stored as instructions and only executed when you explicitly request the results.</span>\n<span class=\"paragraph\"><strong>Key Benefits:</strong>\n- \ud83d\ude80 <strong>Instant Pipeline Building</strong>: No waiting for data loading\n- \ud83d\udcbe <strong>Memory Efficient</strong>: Only load what you need\n- \ud83d\udd04 <strong>Composable</strong>: Operations can be combined and preserved\n- \u26a1 <strong>SQL Performance</strong>: Leverage database-level optimizations\n- \ud83e\uddec <strong>Scanpy Compatible</strong>: Familiar interface with performance benefits</span></span>"}, "type": "data"}]}, {"code_hash": "1b3a67a5f4de2dd7e33027b6ffe747db", "console": [{"name": "stdout", "text": "\n  z Z\n ( - . - )\n /  ^ \\ \u26a1\n(  (_)  (_) )\n \\_______/ \n\n\ud83d\udcca SLAF Dataset Loaded: pbmc3k_processed.slaf\n   \u2022 Shape: 2,695 cells \u00d7 1,863 genes\n   \u2022 Format: SLAF v0.1\n   \u2022 Optimizations: use_integer_keys: True\n   \u2022 Status: Ready for queries (metadata loading in background)\n\n\u2705 Loaded dataset: 2,695 cells \u00d7 1,863 genes\n   Type: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Expression matrix type: <class 'slaf.integrations.anndata.LazyExpressionMatrix'>\n", "type": "stream"}], "id": "vblA", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "75f5c8abad0ffa3e12f1e8ea9d969ccd", "console": [], "id": "bkHC", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"1-understanding-lazy-objects\">1. Understanding Lazy Objects</h2>\n<span class=\"paragraph\">SLAF provides two main lazy object types:</span>\n<ul>\n<li>\n<span class=\"paragraph\"><strong>LazyAnnData</strong>: Lazy version of AnnData with scanpy compatibility</span>\n</li>\n<li>\n<span class=\"paragraph\"><strong>LazyExpressionMatrix</strong>: Lazy version of the expression matrix</span>\n</li>\n</ul></span>"}, "type": "data"}]}, {"code_hash": "27abcbd6b6eafac1082f02ff3d9342f2", "console": [{"name": "stdout", "text": "\ud83d\udd0d Lazy Object Types\n==============================\n1. LazyAnnData type: <class 'slaf.integrations.anndata.LazyAnnData'>\n   - Shape: (2695, 1863)\nLoading metadata in background... (this may take a few seconds)\n", "type": "stream"}, {"name": "stdout", "text": "   - Obs columns: ['n_genes', 'n_genes_by_counts', 'total_counts', 'leiden', 'batch', 'high_mito', 'pct_counts_mt', 'high_genes']\n   - Var columns: ['gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm']\n\n2. LazyExpressionMatrix type: <class 'slaf.integrations.anndata.LazyExpressionMatrix'>\n   - Shape: (2695, 1863)\n   - Parent: <class 'slaf.integrations.anndata.LazyAnnData'>\n\n3. Key insight: These objects store operations, not data!\n   - No data is loaded until you call .compute()\n   - Operations are composed efficiently\n   - Memory usage stays low\n", "type": "stream"}], "id": "lEQa", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "a5cb9b5af5e969c286ca73720febe56e", "console": [], "id": "PKri", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"2-explicit-computation-control\">2. Explicit Computation Control</h2>\n<span class=\"paragraph\">You control when data is actually computed using these methods:</span></span>"}, "type": "data"}]}, {"code_hash": "5b178fc99a1c074c19665d89a06f9f4c", "console": [{"name": "stdout", "text": "\ud83c\udf9b\ufe0f Explicit Computation Control\n===================================\nAvailable computation methods:\n1. adata.compute() \u2192 native AnnData object\n2. adata.X.compute() \u2192 scipy.sparse.csr_matrix\n3. adata.obs \u2192 pandas.DataFrame (cell metadata)\n4. adata.var \u2192 pandas.DataFrame (gene metadata)\n\nLet's demonstrate:\n\n1. Computing expression matrix...\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.2288s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (2695, 1863)\n   Memory: 1.6 MB\n\n2. Accessing cell metadata...\n   \u2705 Accessed in 0.0000s\n   Type: <class 'pandas.core.frame.DataFrame'>\n   Shape: (2695, 8)\n", "type": "stream"}], "id": "Xref", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "c63d9fc9f55bad77978773a461777efa", "console": [], "id": "SFPL", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"3-slicing-patterns-all-the-ways-to-slice\">3. Slicing Patterns - All the Ways to Slice</h2>\n<span class=\"paragraph\">SLAF supports multiple slicing patterns, all of which are lazy:</span></span>"}, "type": "data"}]}, {"code_hash": "199d1d90390bd28f946f91839a475656", "console": [{"name": "stdout", "text": "\u2702\ufe0f Slicing Patterns\n=========================\n1. Basic integer slicing:\n   adata[:100, :50] \u2192 <class 'slaf.integrations.anndata.LazyAnnData'> with shape (100, 50)\n\n2. Expression matrix slicing:\n   adata.X[:100, :50] \u2192 <class 'slaf.integrations.anndata.LazyExpressionMatrix'> with shape (100, 50)\n\n3. Boolean indexing (after QC metrics are available):\n   adata[high_quality_mask, :] \u2192 <class 'slaf.integrations.anndata.LazyAnnData'> with shape (2695, 1863)\n\n4. Mixed indexing:\n   adata[:100, adata.var.index[:50]] \u2192 <class 'slaf.integrations.anndata.LazyAnnData'> with shape (100, 1863)\n\nKey insight: All slicing returns lazy objects!\n", "type": "stream"}], "id": "BYtC", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "8dcce7dd085aa1c193e37db381119a96", "console": [], "id": "RGSE", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"4-transformation-patterns\">4. Transformation Patterns</h2>\n<span class=\"paragraph\">SLAF supports lazy transformations that are stored and applied when needed:</span></span>"}, "type": "data"}]}, {"code_hash": "dab326a7d7603e0f09f85c86171ff8aa", "console": [{"name": "stdout", "text": "\n  z Z\n ( - . - )\n /  ^ \\ \u26a1\n(  (_)  (_) )\n \\_______/ \n\n\ud83d\udcca SLAF Dataset Loaded: pbmc3k_processed.slaf\n   \u2022 Shape: 2,695 cells \u00d7 1,863 genes\n   \u2022 Format: SLAF v0.1\n   \u2022 Optimizations: use_integer_keys: True\n   \u2022 Status: Ready for queries (metadata loading in background)\n\n\u2705 Loaded fresh dataset for transformations\n", "type": "stream"}], "id": "Kclp", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "78614dd4b31d97af81dedb11eb4af53f", "console": [{"name": "stdout", "text": "\ud83d\udd04 Transformation Patterns\n==============================\n1. Single transformation:\n", "type": "stream"}, {"name": "stdout", "text": "   normalize_total() \u2192 <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations stored: ['normalize_total']\n\n2. Chained transformations:\n   normalize_total().log1p() \u2192 <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations stored: ['normalize_total', 'log1p']\n\n3. Transformation on sliced data:\n", "type": "stream"}, {"name": "stdout", "text": "   adata[:100, :50].normalize_total() \u2192 <class 'slaf.integrations.anndata.LazyAnnData'>\n   Shape: (100, 50)\n\n4. Multiple transformations on slice:\n   Multiple transformations on slice \u2192 <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations: ['normalize_total', 'log1p']\n", "type": "stream"}], "id": "emfo", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "62e478d2b023db6c22f2b1be709a793e", "console": [{"name": "stdout", "text": "\u26a1 Applying Transformations\n==============================\n1. Computing transformed data:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 1.8034s\n   Type: <class 'anndata._core.anndata.AnnData'>\n   Shape: (2695, 1863)\n\n2. Computing transformed slice:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.2075s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (2695, 1863)\n\n3. Computing multi-transformed slice:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.2112s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (2695, 1863)\n", "type": "stream"}], "id": "Hstk", "outputs": [{"data": {"application/json": "[\"text/plain:AnnData object with n_obs \\u00d7 n_vars = 2695 \\u00d7 1863\\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'leiden', 'batch', 'high_mito', 'pct_counts_mt', 'high_genes'\\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\", \"text/plain:<Compressed Sparse Row sparse matrix of dtype 'float32'\\n\\twith 415134 stored elements and shape (2695, 1863)>\\n  Coords\\tValues\\n  (0, 5)\\t88.40206909179688\\n  (0, 16)\\t64.94993591308594\\n  (0, 24)\\t64.94993591308594\\n  (0, 48)\\t64.94993591308594\\n  (0, 52)\\t64.94993591308594\\n  (0, 56)\\t64.94993591308594\\n  (0, 68)\\t64.94993591308594\\n  (0, 114)\\t64.94993591308594\\n  (0, 122)\\t64.94993591308594\\n  (0, 140)\\t113.72050476074219\\n  (0, 152)\\t64.94993591308594\\n  (0, 176)\\t88.40206909179688\\n  (0, 185)\\t64.94993591308594\\n  (0, 204)\\t64.94993591308594\\n  (0, 212)\\t64.94993591308594\\n  (0, 226)\\t64.94993591308594\\n  (0, 230)\\t64.94993591308594\\n  (0, 232)\\t64.94993591308594\\n  (0, 239)\\t88.40206909179688\\n  (0, 242)\\t64.94993591308594\\n  (0, 243)\\t64.94993591308594\\n  (0, 268)\\t64.94993591308594\\n  (0, 278)\\t64.94993591308594\\n  (0, 284)\\t64.94993591308594\\n  (0, 313)\\t64.94993591308594\\n  :\\t:\\n  (2694, 1398)\\t1.798457384109497\\n  (2694, 1401)\\t1.798457384109497\\n  (2694, 1404)\\t1.798457384109497\\n  (2694, 1412)\\t1.798457384109497\\n  (2694, 1413)\\t1.798457384109497\\n  (2694, 1424)\\t1.798457384109497\\n  (2694, 1451)\\t1.798457384109497\\n  (2694, 1473)\\t1.798457384109497\\n  (2694, 1475)\\t2.4051997661590576\\n  (2694, 1495)\\t1.798457384109497\\n  (2694, 1500)\\t1.798457384109497\\n  (2694, 1505)\\t1.798457384109497\\n  (2694, 1545)\\t2.4051997661590576\\n  (2694, 1554)\\t1.798457384109497\\n  (2694, 1584)\\t1.798457384109497\\n  (2694, 1606)\\t1.798457384109497\\n  (2694, 1616)\\t1.798457384109497\\n  (2694, 1626)\\t1.798457384109497\\n  (2694, 1688)\\t1.798457384109497\\n  (2694, 1754)\\t1.798457384109497\\n  (2694, 1809)\\t1.798457384109497\\n  (2694, 1814)\\t2.4051997661590576\\n  (2694, 1826)\\t1.798457384109497\\n  (2694, 1830)\\t1.798457384109497\\n  (2694, 1839)\\t1.798457384109497\", \"text/plain:<Compressed Sparse Row sparse matrix of dtype 'float32'\\n\\twith 415134 stored elements and shape (2695, 1863)>\\n  Coords\\tValues\\n  (0, 5)\\t4.4931440353393555\\n  (0, 16)\\t4.1888957023620605\\n  (0, 24)\\t4.1888957023620605\\n  (0, 48)\\t4.1888957023620605\\n  (0, 52)\\t4.1888957023620605\\n  (0, 56)\\t4.1888957023620605\\n  (0, 68)\\t4.1888957023620605\\n  (0, 114)\\t4.1888957023620605\\n  (0, 122)\\t4.1888957023620605\\n  (0, 140)\\t4.742498874664307\\n  (0, 152)\\t4.1888957023620605\\n  (0, 176)\\t4.4931440353393555\\n  (0, 185)\\t4.1888957023620605\\n  (0, 204)\\t4.1888957023620605\\n  (0, 212)\\t4.1888957023620605\\n  (0, 226)\\t4.1888957023620605\\n  (0, 230)\\t4.1888957023620605\\n  (0, 232)\\t4.1888957023620605\\n  (0, 239)\\t4.4931440353393555\\n  (0, 242)\\t4.1888957023620605\\n  (0, 243)\\t4.1888957023620605\\n  (0, 268)\\t4.1888957023620605\\n  (0, 278)\\t4.1888957023620605\\n  (0, 284)\\t4.1888957023620605\\n  (0, 313)\\t4.1888957023620605\\n  :\\t:\\n  (2694, 1398)\\t1.0290683507919312\\n  (2694, 1401)\\t1.0290683507919312\\n  (2694, 1404)\\t1.0290683507919312\\n  (2694, 1412)\\t1.0290683507919312\\n  (2694, 1413)\\t1.0290683507919312\\n  (2694, 1424)\\t1.0290683507919312\\n  (2694, 1451)\\t1.0290683507919312\\n  (2694, 1473)\\t1.0290683507919312\\n  (2694, 1475)\\t1.2253036499023438\\n  (2694, 1495)\\t1.0290683507919312\\n  (2694, 1500)\\t1.0290683507919312\\n  (2694, 1505)\\t1.0290683507919312\\n  (2694, 1545)\\t1.2253036499023438\\n  (2694, 1554)\\t1.0290683507919312\\n  (2694, 1584)\\t1.0290683507919312\\n  (2694, 1606)\\t1.0290683507919312\\n  (2694, 1616)\\t1.0290683507919312\\n  (2694, 1626)\\t1.0290683507919312\\n  (2694, 1688)\\t1.0290683507919312\\n  (2694, 1754)\\t1.0290683507919312\\n  (2694, 1809)\\t1.0290683507919312\\n  (2694, 1814)\\t1.2253036499023438\\n  (2694, 1826)\\t1.0290683507919312\\n  (2694, 1830)\\t1.0290683507919312\\n  (2694, 1839)\\t1.0290683507919312\"]"}, "type": "data"}]}, {"code_hash": "31cc1e49d33335690bedb214b1570f4d", "console": [], "id": "nWHF", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"5-transformation-preservation-through-operations\">5. Transformation Preservation Through Operations</h2>\n<span class=\"paragraph\">Transformations are preserved through slicing and other operations:</span></span>"}, "type": "data"}]}, {"code_hash": "9f46c11315ca9c36ae8db9e93d02530b", "console": [{"name": "stdout", "text": "\n  z Z\n ( - . - )\n /  ^ \\ \u26a1\n(  (_)  (_) )\n \\_______/ \n\n\ud83d\udcca SLAF Dataset Loaded: pbmc3k.slaf\n   \u2022 Shape: 2,700 cells \u00d7 32,738 genes\n   \u2022 Format: SLAF v0.1\n   \u2022 Optimizations: use_integer_keys: True\n   \u2022 Status: Ready for queries (metadata loading in background)\n\n", "type": "stream"}], "id": "iLit", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "6f443d1465f728c5930dad9639ce3e4d", "console": [{"name": "stdout", "text": "\ud83d\udd04 Transformation Preservation\n===================================\n1. Apply transformations first, then slice:\n", "type": "stream"}, {"name": "stdout", "text": "   Original transformations: ['normalize_total', 'log1p']\n   Slice transformations: ['normalize_total', 'log1p']\n\n2. Slice first, then apply transformations:\n", "type": "stream"}, {"name": "stdout", "text": "   Transformed slice: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations: ['normalize_total', 'log1p']\n\n3. Complex slicing patterns preserve transformations:\n   Note: Chained slicing (e.g., adata[:200, :100][:50, :25]) is not supported.\n   Use single-step slicing instead: adata[50:250, 25:125]\n   Single-step slice: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations preserved: ['normalize_total', 'log1p']\n   Boolean mask slice: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations preserved: ['normalize_total', 'log1p']\n   Step slice: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Transformations preserved: ['normalize_total', 'log1p']\n", "type": "stream"}], "id": "ZHCJ", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "ffeb2a68524b726c24b91f62a943ef0f", "console": [{"name": "stdout", "text": "\u2705 Verifying Transformation Preservation\n========================================\n1. Computing slice with preserved transformations:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.2026s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (100, 50)\n\n2. Computing slice with applied transformations:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 1.2484s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (2700, 32738)\n\n3. Computing single-step slice with preserved transformations:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.1922s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (200, 100)\n", "type": "stream"}], "id": "ROlb", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "87bb153b5d40e6bd9067b2faef2f8e30", "console": [], "id": "qnkX", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"6-performance-benefits-building-complex-pipelines\">6. Performance Benefits - Building Complex Pipelines</h2>\n<span class=\"paragraph\">Let's see how lazy evaluation enables efficient complex pipelines:</span></span>"}, "type": "data"}]}, {"code_hash": "3b710cc181d374a19352beaef1e67062", "console": [{"name": "stdout", "text": "\u26a1 Performance Benefits\n=========================\n1. Building complex pipeline (no computation yet):\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Pipeline built in 0.0114s\n   Final object: <class 'slaf.integrations.anndata.LazyAnnData'>\n   Expected shape: (500, 200)\n   Transformations: ['normalize_total', 'log1p']\n\n2. Computing the final result:\n", "type": "stream"}, {"name": "stdout", "text": "   \u2705 Computed in 0.0493s\n   Type: <class 'scipy.sparse._csr.csr_matrix'>\n   Shape: (500, 200)\n\n3. Total time: 0.0607s\n   Key insight: Pipeline building is instant, computation happens only when needed!\n", "type": "stream"}], "id": "TqIu", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "7f9fa546b1b9f8744da767eb2af75d33", "console": [], "id": "Vxnm", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"7-memory-efficiency-comparison\">7. Memory Efficiency Comparison</h2>\n<span class=\"paragraph\">Let's compare memory usage between lazy and eager approaches:</span></span>"}, "type": "data"}]}, {"code_hash": "6dfba50f4f01f8ecfececf41d0630ae3", "console": [{"name": "stdout", "text": "\ud83d\udcbe Memory Efficiency Comparison\n===================================\n\n  z Z\n ( - . - )\n /  ^ \\ \u26a1\n(  (_)  (_) )\n \\_______/ \n\n\ud83d\udcca SLAF Dataset Loaded: pbmc3k_processed.slaf\n   \u2022 Shape: 2,695 cells \u00d7 1,863 genes\n   \u2022 Format: SLAF v0.1\n   \u2022 Optimizations: use_integer_keys: True\n   \u2022 Status: Ready for queries (metadata loading in background)\n\n1. Memory after loading lazy data:\n   Lazy loading: 1083.3 MB\n\n2. Memory after computing full dataset:\n", "type": "stream"}, {"name": "stdout", "text": "   Eager loading: 1096.4 MB\n   Memory increase: 13.1 MB\n\n3. Memory after computing small slice:\n", "type": "stream"}, {"name": "stdout", "text": "   Small slice: 1098.1 MB\n   Memory increase: 1.8 MB\n\nKey insight: Lazy loading uses 1083.3 MB vs eager loading 1096.4 MB\nMemory savings: 1.2%\n", "type": "stream"}], "id": "DnEU", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "c7949aa9588890c8628bbf631d148263", "console": [], "id": "ulZA", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"8-advanced-slicing-patterns\">8. Advanced Slicing Patterns</h2>\n<span class=\"paragraph\">Let's explore more advanced slicing patterns:</span></span>"}, "type": "data"}]}, {"code_hash": "9c331d9780819a8c1c3c08537ac2504c", "console": [{"name": "stdout", "text": "\ud83d\udd2c Advanced Slicing Patterns\n===================================\n\n  z Z\n ( - . - )\n /  ^ \\ \u26a1\n(  (_)  (_) )\n \\_______/ \n\n\ud83d\udcca SLAF Dataset Loaded: pbmc3k_processed.slaf\n   \u2022 Shape: 2,695 cells \u00d7 1,863 genes\n   \u2022 Format: SLAF v0.1\n   \u2022 Optimizations: use_integer_keys: True\n   \u2022 Status: Ready for queries (metadata loading in background)\n\n", "type": "stream"}, {"name": "stdout", "text": "1. Boolean indexing with QC metrics:\n   High quality cells: (2695, 1863)\n\n2. Gene-based filtering:\n   Highly variable genes: (2695, 1863)\n\n3. Combined cell and gene filtering:\n   Combined filtering: (2695, 100)\n\n4. Expression-based filtering:\n   High count cells: (2695, 1863)\n", "type": "stream"}], "id": "ecfG", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "e44442767b8873d3214ad6e019ecdce0", "console": [], "id": "Pvdt", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"9-lazy-vs-eager-performance-comparison\">9. Lazy vs Eager Performance Comparison</h2>\n<span class=\"paragraph\">Let's compare the performance of lazy vs eager approaches:</span></span>"}, "type": "data"}]}, {"code_hash": "9f270672f0d74f498325e648828e5372", "console": [{"name": "stdout", "text": "\u26a1 Lazy vs Eager Performance\n===================================\nScenario: normalize_total \u2192 log1p \u2192 slice[:100, :50]\n\n1. Lazy approach:\n", "type": "stream"}, {"name": "stdout", "text": "   Build time: 0.0120s\n   Compute time: 0.0365s\n   Total time: 0.0486s\n\n2. Eager approach (simulated):\n", "type": "stream"}, {"name": "stdout", "text": "   Load time: 0.2038s\n   Transformations would be done in memory (slower for large datasets)\n\n3. Key benefits:\n   - Lazy: Build complex pipelines instantly\n   - Lazy: Only compute what you need\n   - Lazy: Memory efficient\n   - Lazy: SQL-level performance for operations\n", "type": "stream"}], "id": "ZBYS", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "8c92a9bf3966af0721a5b557dc7b5265", "console": [], "id": "aLJB", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"10-best-practices-and-tips\">10. Best Practices and Tips</h2>\n<span class=\"paragraph\">Here are some best practices for using SLAF's lazy evaluation:</span></span>"}, "type": "data"}]}, {"code_hash": "145f0f83a2c3089b289fadf25ecaac34", "console": [{"name": "stdout", "text": "\ud83d\udca1 Best Practices and Tips\n==============================\n1. Pipeline Building:\n   \u2705 Build complete pipelines before computing\n   \u2705 Chain transformations: adata.normalize_total().log1p()\n   \u2705 Slice after transformations for efficiency\n\n2. Computation Control:\n   \u2705 Use .compute() only when you need the data\n   \u2705 Use .obs or .var for metadata\n   \u2705 Use .X.compute() for expression matrix only\n\n3. Memory Management:\n   \u2705 Keep lazy objects for intermediate results\n   \u2705 Compute only final results\n   \u2705 Use slicing to reduce memory usage\n\n4. Performance Optimization:\n   \u2705 Leverage SQL-level operations\n   \u2705 Use boolean indexing for filtering\n   \u2705 Combine operations in single queries when possible\n\n5. Debugging:\n   \u2705 Check object types: type(adata)\n   \u2705 Check transformations: adata._transformations\n   \u2705 Use .info() for dataset overview\n", "type": "stream"}], "id": "nHfw", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "062b13d12cd10691103759404482ba25", "console": [], "id": "xXTn", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"summary\">Summary</h2>\n<span class=\"paragraph\"><strong>What you've learned about SLAF's lazy processing:</strong></span>\n<ol>\n<li><strong>Lazy Objects</strong>: LazyAnnData and LazyExpressionMatrix store operations, not data</li>\n<li><strong>Explicit Control</strong>: Use .compute() methods to control when data is processed</li>\n<li><strong>Slicing Patterns</strong>: Multiple slicing patterns, all lazy and composable</li>\n<li><strong>Transformations</strong>: Lazy transformations that are preserved through operations</li>\n<li><strong>Performance</strong>: Build complex pipelines instantly, compute only when needed</li>\n<li><strong>Memory Efficiency</strong>: Significant memory savings compared to eager loading</li>\n<li><strong>Best Practices</strong>: Guidelines for optimal lazy evaluation usage</li>\n</ol>\n<span class=\"paragraph\"><strong>Next Steps:</strong>\n- <strong>03-ml-training-pipeline.py</strong>: Complete ML training workflows with tokenizers and dataloaders</span></span>"}, "type": "data"}]}], "metadata": {"marimo_version": "0.14.0"}, "version": "1"},
            "runtimeConfig": null,
        };
    </script>

<marimo-code hidden="">
    import%20marimo%0A%0A__generated_with%20%3D%20%220.14.0%22%0Aapp%20%3D%20marimo.App(width%3D%22medium%22)%0A%0A%0A%40app.cell%0Adef%20_()%3A%0A%20%20%20%20import%20time%0A%0A%20%20%20%20import%20marimo%20as%20mo%0A%0A%20%20%20%20from%20slaf.integrations%20import%20scanpy%20as%20slaf_scanpy%0A%20%20%20%20from%20slaf.integrations.anndata%20import%20read_slaf%0A%0A%20%20%20%20return%20mo%2C%20read_slaf%2C%20slaf_scanpy%2C%20time%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%20SLAF%20Lazy%20Processing%20Deep%20Dive%0A%0A%20%20%20%20This%20notebook%20explores%20SLAF's%20lazy%20evaluation%20capabilities%20in%20detail.%20You'll%20learn%20how%20to%3A%0A%0A%20%20%20%20-%20Build%20complex%20analysis%20pipelines%20without%20loading%20data%0A%20%20%20%20-%20Apply%20multiple%20transformations%20efficiently%0A%20%20%20%20-%20Use%20different%20slicing%20patterns%0A%20%20%20%20-%20Control%20when%20computation%20happens%0A%20%20%20%20-%20Understand%20performance%20benefits%0A%0A%20%20%20%20**Key%20Concept**%3A%20Lazy%20evaluation%20means%20operations%20are%20stored%20as%20instructions%20and%20only%20executed%20when%20you%20explicitly%20request%20the%20results.%0A%0A%20%20%20%20**Key%20Benefits%3A**%0A%20%20%20%20-%20%F0%9F%9A%80%20**Instant%20Pipeline%20Building**%3A%20No%20waiting%20for%20data%20loading%0A%20%20%20%20-%20%F0%9F%92%BE%20**Memory%20Efficient**%3A%20Only%20load%20what%20you%20need%0A%20%20%20%20-%20%F0%9F%94%84%20**Composable**%3A%20Operations%20can%20be%20combined%20and%20preserved%0A%20%20%20%20-%20%E2%9A%A1%20**SQL%20Performance**%3A%20Leverage%20database-level%20optimizations%0A%20%20%20%20-%20%F0%9F%A7%AC%20**Scanpy%20Compatible**%3A%20Familiar%20interface%20with%20performance%20benefits%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf)%3A%0A%20%20%20%20%23%20Load%20data%20for%20lazy%20processing%20examples%0A%20%20%20%20adata%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%20%20%20%20print(f%22%E2%9C%85%20Loaded%20dataset%3A%20%7Badata.shape%5B0%5D%3A%2C%7D%20cells%20%C3%97%20%7Badata.shape%5B1%5D%3A%2C%7D%20genes%22)%0A%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(adata)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Expression%20matrix%20type%3A%20%7Btype(adata.X)%7D%22)%0A%20%20%20%20return%20(adata%2C)%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%201.%20Understanding%20Lazy%20Objects%0A%0A%20%20%20%20SLAF%20provides%20two%20main%20lazy%20object%20types%3A%0A%0A%20%20%20%20-%20**LazyAnnData**%3A%20Lazy%20version%20of%20AnnData%20with%20scanpy%20compatibility%0A%0A%20%20%20%20-%20**LazyExpressionMatrix**%3A%20Lazy%20version%20of%20the%20expression%20matrix%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata)%3A%0A%20%20%20%20%23%20Demonstrate%20lazy%20object%20types%0A%20%20%20%20print(%22%F0%9F%94%8D%20Lazy%20Object%20Types%22)%0A%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20print(f%221.%20LazyAnnData%20type%3A%20%7Btype(adata)%7D%22)%0A%20%20%20%20print(f%22%20%20%20-%20Shape%3A%20%7Badata.shape%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20-%20Obs%20columns%3A%20%7Blist(adata.obs.columns)%20if%20hasattr(adata%2C%20'obs')%20and%20adata.obs%20is%20not%20None%20else%20'Not%20loaded'%7D%22%0A%20%20%20%20)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20-%20Var%20columns%3A%20%7Blist(adata.var.columns)%20if%20hasattr(adata%2C%20'var')%20and%20adata.var%20is%20not%20None%20else%20'Not%20loaded'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(f%22%5Cn2.%20LazyExpressionMatrix%20type%3A%20%7Btype(adata.X)%7D%22)%0A%20%20%20%20print(f%22%20%20%20-%20Shape%3A%20%7Badata.X.shape%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20-%20Parent%3A%20%7Btype(adata.X.parent_adata)%20if%20hasattr(adata.X%2C%20'parent_adata')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(%22%5Cn3.%20Key%20insight%3A%20These%20objects%20store%20operations%2C%20not%20data!%22)%0A%20%20%20%20print(%22%20%20%20-%20No%20data%20is%20loaded%20until%20you%20call%20.compute()%22)%0A%20%20%20%20print(%22%20%20%20-%20Operations%20are%20composed%20efficiently%22)%0A%20%20%20%20print(%22%20%20%20-%20Memory%20usage%20stays%20low%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%202.%20Explicit%20Computation%20Control%0A%0A%20%20%20%20You%20control%20when%20data%20is%20actually%20computed%20using%20these%20methods%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata%2C%20time)%3A%0A%20%20%20%20def%20demonstrate_computation_control()%3A%0A%20%20%20%20%20%20%20%20%23%20Demonstrate%20explicit%20computation%20control%0A%20%20%20%20%20%20%20%20print(%22%F0%9F%8E%9B%EF%B8%8F%20Explicit%20Computation%20Control%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%20%20%20%20print(%22Available%20computation%20methods%3A%22)%0A%20%20%20%20%20%20%20%20print(%221.%20adata.compute()%20%E2%86%92%20native%20AnnData%20object%22)%0A%20%20%20%20%20%20%20%20print(%222.%20adata.X.compute()%20%E2%86%92%20scipy.sparse.csr_matrix%22)%0A%20%20%20%20%20%20%20%20print(%223.%20adata.obs%20%E2%86%92%20pandas.DataFrame%20(cell%20metadata)%22)%0A%20%20%20%20%20%20%20%20print(%224.%20adata.var%20%E2%86%92%20pandas.DataFrame%20(gene%20metadata)%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5CnLet's%20demonstrate%3A%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Compute%20just%20the%20expression%20matrix%0A%20%20%20%20%20%20%20%20print(%22%5Cn1.%20Computing%20expression%20matrix...%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20sparse_matrix%20%3D%20adata.X.compute()%0A%20%20%20%20%20%20%20%20compute_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Bcompute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(sparse_matrix)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bsparse_matrix.shape%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Memory%3A%20%7Bsparse_matrix.data.nbytes%20%2F%201024%20%2F%201024%3A.1f%7D%20MB%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Access%20cell%20metadata%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Accessing%20cell%20metadata...%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20obs_df%20%3D%20adata.obs%0A%20%20%20%20%20%20%20%20obs_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Accessed%20in%20%7Bobs_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(obs_df)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bobs_df.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20return%20(sparse_matrix%2C%20obs_df)%0A%0A%20%20%20%20sparse_matrix%2C%20obs_df%20%3D%20demonstrate_computation_control()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%203.%20Slicing%20Patterns%20-%20All%20the%20Ways%20to%20Slice%0A%0A%20%20%20%20SLAF%20supports%20multiple%20slicing%20patterns%2C%20all%20of%20which%20are%20lazy%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata)%3A%0A%20%20%20%20%23%20Demonstrate%20different%20slicing%20patterns%0A%20%20%20%20def%20demonstrate_slicing_patterns(adata)%3A%0A%20%20%20%20%20%20%20%20print(%22%E2%9C%82%EF%B8%8F%20Slicing%20Patterns%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2025)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Basic%20integer%20slicing%3A%22)%0A%20%20%20%20%20%20%20%20slice1%20%3D%20adata%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20adata%5B%3A100%2C%20%3A50%5D%20%E2%86%92%20%7Btype(slice1)%7D%20with%20shape%20%7Bslice1.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Expression%20matrix%20slicing%3A%22)%0A%20%20%20%20%20%20%20%20slice2%20%3D%20adata.X%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20adata.X%5B%3A100%2C%20%3A50%5D%20%E2%86%92%20%7Btype(slice2)%7D%20with%20shape%20%7Bslice2.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Boolean%20indexing%20(after%20QC%20metrics%20are%20available)%3A%22)%0A%20%20%20%20%20%20%20%20%23%20First%20add%20some%20QC%20metrics%0A%20%20%20%20%20%20%20%20if%20(%0A%20%20%20%20%20%20%20%20%20%20%20%20hasattr(adata%2C%20%22obs%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20and%20adata.obs%20is%20not%20None%0A%20%20%20%20%20%20%20%20%20%20%20%20and%20%22n_genes_by_counts%22%20in%20adata.obs.columns%0A%20%20%20%20%20%20%20%20)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20high_quality_mask%20%3D%20adata.obs%5B%22n_genes_by_counts%22%5D%20%3E%201000%0A%20%20%20%20%20%20%20%20%20%20%20%20slice3%20%3D%20adata%5Bhigh_quality_mask%2C%20%3A%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f%22%20%20%20adata%5Bhigh_quality_mask%2C%20%3A%5D%20%E2%86%92%20%7Btype(slice3)%7D%20with%20shape%20%7Bslice3.shape%7D%22%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%20%20%20(QC%20metrics%20not%20available%20yet%20-%20will%20be%20computed%20in%20preprocessing%20section)%22%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn4.%20Mixed%20indexing%3A%22)%0A%20%20%20%20%20%20%20%20slice4%20%3D%20adata%5B%3A100%2C%20adata.var.index%5B%3A50%5D%5D%0A%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20f%22%20%20%20adata%5B%3A100%2C%20adata.var.index%5B%3A50%5D%5D%20%E2%86%92%20%7Btype(slice4)%7D%20with%20shape%20%7Bslice4.shape%7D%22%0A%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20print(%22%5CnKey%20insight%3A%20All%20slicing%20returns%20lazy%20objects!%22)%0A%0A%20%20%20%20demonstrate_slicing_patterns(adata)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%204.%20Transformation%20Patterns%0A%0A%20%20%20%20SLAF%20supports%20lazy%20transformations%20that%20are%20stored%20and%20applied%20when%20needed%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf)%3A%0A%20%20%20%20%23%20Load%20fresh%20data%20for%20transformation%20examples%0A%20%20%20%20adata_fresh%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%20%20%20%20print(%22%E2%9C%85%20Loaded%20fresh%20dataset%20for%20transformations%22)%0A%20%20%20%20return%20(adata_fresh%2C)%0A%0A%0A%40app.cell%0Adef%20_(adata_fresh%2C%20slaf_scanpy)%3A%0A%20%20%20%20%23%20Demonstrate%20transformation%20patterns%0A%20%20%20%20print(%22%F0%9F%94%84%20Transformation%20Patterns%22)%0A%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20print(%221.%20Single%20transformation%3A%22)%0A%20%20%20%20adata_norm%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20adata_fresh%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20print(f%22%20%20%20normalize_total()%20%E2%86%92%20%7Btype(adata_norm)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%20stored%3A%20%7Blist(adata_norm._transformations.keys())%20if%20hasattr(adata_norm%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(%22%5Cn2.%20Chained%20transformations%3A%22)%0A%20%20%20%20adata_processed%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20adata_fresh%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20adata_processed%20%3D%20slaf_scanpy.pp.log1p(adata_processed%2C%20inplace%3DFalse)%0A%20%20%20%20print(f%22%20%20%20normalize_total().log1p()%20%E2%86%92%20%7Btype(adata_processed)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%20stored%3A%20%7Blist(adata_processed._transformations.keys())%20if%20hasattr(adata_processed%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(%22%5Cn3.%20Transformation%20on%20sliced%20data%3A%22)%0A%20%20%20%20%23%20First%20slice%2C%20then%20apply%20transformation%20(safer%20pattern)%0A%20%20%20%20slice_data%20%3D%20adata_fresh%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20slice_transformed%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20slice_data%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20print(f%22%20%20%20adata%5B%3A100%2C%20%3A50%5D.normalize_total()%20%E2%86%92%20%7Btype(slice_transformed)%7D%22)%0A%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bslice_transformed.shape%7D%22)%0A%0A%20%20%20%20print(%22%5Cn4.%20Multiple%20transformations%20on%20slice%3A%22)%0A%20%20%20%20%23%20First%20slice%2C%20then%20apply%20transformations%20(safer%20pattern)%0A%20%20%20%20slice_data%20%3D%20adata_fresh%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20slice_multi%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20slice_data%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20slice_multi%20%3D%20slaf_scanpy.pp.log1p(slice_multi%2C%20inplace%3DFalse)%0A%20%20%20%20print(f%22%20%20%20Multiple%20transformations%20on%20slice%20%E2%86%92%20%7Btype(slice_multi)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%3A%20%7Blist(slice_multi._transformations.keys())%20if%20hasattr(slice_multi%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20return%20adata_processed%2C%20slice_multi%2C%20slice_transformed%0A%0A%0A%40app.cell%0Adef%20_(adata_processed%2C%20slice_multi%2C%20slice_transformed%2C%20time)%3A%0A%20%20%20%20def%20demonstrate_transformation_application()%3A%0A%20%20%20%20%20%20%20%20%23%20Demonstrate%20transformation%20application%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A1%20Applying%20Transformations%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Computing%20transformed%20data%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20native_processed%20%3D%20adata_processed.compute()%0A%20%20%20%20%20%20%20%20process_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Bprocess_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(native_processed)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bnative_processed.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Computing%20transformed%20slice%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20native_slice_matrix%20%3D%20slice_transformed.X.compute()%0A%20%20%20%20%20%20%20%20slice_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Bslice_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(native_slice_matrix)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bnative_slice_matrix.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Computing%20multi-transformed%20slice%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20native_multi_matrix%20%3D%20slice_multi.X.compute()%0A%20%20%20%20%20%20%20%20multi_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Bmulti_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(native_multi_matrix)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bnative_multi_matrix.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20return%20(native_processed%2C%20native_slice_matrix%2C%20native_multi_matrix)%0A%0A%20%20%20%20demonstrate_transformation_application()%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%205.%20Transformation%20Preservation%20Through%20Operations%0A%0A%20%20%20%20Transformations%20are%20preserved%20through%20slicing%20and%20other%20operations%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf)%3A%0A%20%20%20%20%23%20Load%20fresh%20data%20for%20preservation%20examples%0A%20%20%20%20adata_preserve%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k.slaf%22)%0A%20%20%20%20return%20(adata_preserve%2C)%0A%0A%0A%40app.cell%0Adef%20_(adata_preserve%2C%20slaf_scanpy)%3A%0A%20%20%20%20%23%20Demonstrate%20transformation%20preservation%0A%20%20%20%20print(%22%F0%9F%94%84%20Transformation%20Preservation%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20print(%221.%20Apply%20transformations%20first%2C%20then%20slice%3A%22)%0A%20%20%20%20adata_transformed%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20adata_preserve%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20adata_transformed%20%3D%20slaf_scanpy.pp.log1p(adata_transformed%2C%20inplace%3DFalse)%0A%20%20%20%20slice_after%20%3D%20adata_transformed%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Original%20transformations%3A%20%7Blist(adata_transformed._transformations.keys())%20if%20hasattr(adata_transformed%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Slice%20transformations%3A%20%7Blist(slice_after._transformations.keys())%20if%20hasattr(slice_after%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(%22%5Cn2.%20Slice%20first%2C%20then%20apply%20transformations%3A%22)%0A%20%20%20%20slice_before%20%3D%20adata_preserve%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20transformed_slice%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20slice_before%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20)%0A%20%20%20%20transformed_slice%20%3D%20slaf_scanpy.pp.log1p(transformed_slice%2C%20inplace%3DFalse)%0A%20%20%20%20print(f%22%20%20%20Transformed%20slice%3A%20%7Btype(transformed_slice)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%3A%20%7Blist(transformed_slice._transformations.keys())%20if%20hasattr(transformed_slice%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20print(%22%5Cn3.%20Complex%20slicing%20patterns%20preserve%20transformations%3A%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%22%20%20%20Note%3A%20Chained%20slicing%20(e.g.%2C%20adata%5B%3A200%2C%20%3A100%5D%5B%3A50%2C%20%3A25%5D)%20is%20not%20supported.%22%0A%20%20%20%20)%0A%20%20%20%20print(%22%20%20%20Use%20single-step%20slicing%20instead%3A%20adata%5B50%3A250%2C%2025%3A125%5D%22)%0A%0A%20%20%20%20%23%20Single-step%20slicing%20(equivalent%20to%20nested%20slicing)%0A%20%20%20%20single_step_slice%20%3D%20adata_transformed%5B50%3A250%2C%2025%3A125%5D%0A%20%20%20%20print(f%22%20%20%20Single-step%20slice%3A%20%7Btype(single_step_slice)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%20preserved%3A%20%7Blist(single_step_slice._transformations.keys())%20if%20hasattr(single_step_slice%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20%23%20Boolean%20mask%20slicing%0A%20%20%20%20import%20numpy%20as%20np%0A%0A%20%20%20%20cell_mask%20%3D%20np.zeros(adata_transformed.shape%5B0%5D%2C%20dtype%3Dbool)%0A%20%20%20%20cell_mask%5B50%3A250%5D%20%3D%20True%0A%20%20%20%20gene_mask%20%3D%20np.zeros(adata_transformed.shape%5B1%5D%2C%20dtype%3Dbool)%0A%20%20%20%20gene_mask%5B25%3A125%5D%20%3D%20True%0A%20%20%20%20boolean_slice%20%3D%20adata_transformed%5Bcell_mask%2C%20gene_mask%5D%0A%20%20%20%20print(f%22%20%20%20Boolean%20mask%20slice%3A%20%7Btype(boolean_slice)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%20preserved%3A%20%7Blist(boolean_slice._transformations.keys())%20if%20hasattr(boolean_slice%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20%23%20Step%20slicing%0A%20%20%20%20step_slice%20%3D%20adata_transformed%5B%3A%3A4%2C%20%3A%3A2%5D%20%20%23%20Every%204th%20cell%2C%20every%202nd%20gene%0A%20%20%20%20print(f%22%20%20%20Step%20slice%3A%20%7Btype(step_slice)%7D%22)%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%20preserved%3A%20%7Blist(step_slice._transformations.keys())%20if%20hasattr(step_slice%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20)%0A%0A%20%20%20%20return%20single_step_slice%2C%20slice_after%2C%20transformed_slice%0A%0A%0A%40app.cell%0Adef%20_(single_step_slice%2C%20slice_after%2C%20time%2C%20transformed_slice)%3A%0A%20%20%20%20def%20verify_transformation_preservation()%3A%0A%20%20%20%20%20%20%20%20%23%20Verify%20transformation%20preservation%20by%20computing%0A%20%20%20%20%20%20%20%20print(%22%E2%9C%85%20Verifying%20Transformation%20Preservation%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2040)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Computing%20slice%20with%20preserved%20transformations%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20result1%20%3D%20slice_after.X.compute()%0A%20%20%20%20%20%20%20%20time1%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Btime1%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(result1)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bresult1.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Computing%20slice%20with%20applied%20transformations%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20result2%20%3D%20transformed_slice.X.compute()%0A%20%20%20%20%20%20%20%20time2%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Btime2%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(result2)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bresult2.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Computing%20single-step%20slice%20with%20preserved%20transformations%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20result3%20%3D%20single_step_slice.X.compute()%0A%20%20%20%20%20%20%20%20time3%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Btime3%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(result3)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bresult3.shape%7D%22)%0A%0A%20%20%20%20verify_transformation_preservation()%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%206.%20Performance%20Benefits%20-%20Building%20Complex%20Pipelines%0A%0A%20%20%20%20Let's%20see%20how%20lazy%20evaluation%20enables%20efficient%20complex%20pipelines%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata%2C%20slaf_scanpy%2C%20time)%3A%0A%20%20%20%20%23%20Demonstrate%20performance%20benefits%0A%0A%20%20%20%20def%20demonstrate_complex_pipeline(adata)%3A%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A1%20Performance%20Benefits%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2025)%0A%0A%20%20%20%20%20%20%20%20print(%221.%20Building%20complex%20pipeline%20(no%20computation%20yet)%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%0A%20%20%20%20%20%20%20%20%23%20Build%20a%20complex%20pipeline%0A%20%20%20%20%20%20%20%20pipeline%20%3D%20slaf_scanpy.pp.normalize_total(adata%2C%20target_sum%3D1e4%2C%20inplace%3DFalse)%0A%20%20%20%20%20%20%20%20pipeline%20%3D%20slaf_scanpy.pp.log1p(pipeline%2C%20inplace%3DFalse)%0A%0A%20%20%20%20%20%20%20%20%23%20Note%3A%20highly_variable_genes%20returns%20a%20DataFrame%2C%20not%20a%20LazyAnnData%20object%0A%20%20%20%20%20%20%20%20%23%20so%20it%20can't%20be%20chained%20in%20the%20pipeline%20like%20other%20transformations%0A%0A%20%20%20%20%20%20%20%20%23%20Slice%20the%20processed%20data%0A%20%20%20%20%20%20%20%20final_slice%20%3D%20pipeline%5B%3A500%2C%20%3A200%5D%0A%0A%20%20%20%20%20%20%20%20build_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Pipeline%20built%20in%20%7Bbuild_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Final%20object%3A%20%7Btype(final_slice)%7D%22)%0A%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%20%20%20Expected%20shape%3A%20(500%2C%20200)%22%0A%20%20%20%20%20%20%20%20)%20%20%23%20Avoid%20accessing%20.shape%20on%20transformed%20slice%0A%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20f%22%20%20%20Transformations%3A%20%7Blist(final_slice._transformations.keys())%20if%20hasattr(final_slice%2C%20'_transformations')%20else%20'None'%7D%22%0A%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Computing%20the%20final%20result%3A%22)%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20final_result%20%3D%20final_slice.X.compute()%0A%20%20%20%20%20%20%20%20compute_time%20%3D%20time.time()%20-%20start_time%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20%E2%9C%85%20Computed%20in%20%7Bcompute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Type%3A%20%7Btype(final_result)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Shape%3A%20%7Bfinal_result.shape%7D%22)%0A%0A%20%20%20%20%20%20%20%20print(f%22%5Cn3.%20Total%20time%3A%20%7Bbuild_time%20%2B%20compute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(%0A%20%20%20%20%20%20%20%20%20%20%20%20%22%20%20%20Key%20insight%3A%20Pipeline%20building%20is%20instant%2C%20computation%20happens%20only%20when%20needed!%22%0A%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20demonstrate_complex_pipeline(adata)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%207.%20Memory%20Efficiency%20Comparison%0A%0A%20%20%20%20Let's%20compare%20memory%20usage%20between%20lazy%20and%20eager%20approaches%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf)%3A%0A%20%20%20%20%23%20Memory%20efficiency%20comparison%0A%20%20%20%20print(%22%F0%9F%92%BE%20Memory%20Efficiency%20Comparison%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20import%20gc%0A%0A%20%20%20%20import%20psutil%0A%0A%20%20%20%20def%20get_memory_usage()%3A%0A%20%20%20%20%20%20%20%20%22%22%22Get%20current%20memory%20usage%20in%20MB%22%22%22%0A%20%20%20%20%20%20%20%20process%20%3D%20psutil.Process()%0A%20%20%20%20%20%20%20%20return%20process.memory_info().rss%20%2F%201024%20%2F%201024%0A%0A%20%20%20%20%23%20Load%20fresh%20data%0A%20%20%20%20adata_mem%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%0A%20%20%20%20print(%221.%20Memory%20after%20loading%20lazy%20data%3A%22)%0A%20%20%20%20gc.collect()%0A%20%20%20%20lazy_memory%20%3D%20get_memory_usage()%0A%20%20%20%20print(f%22%20%20%20Lazy%20loading%3A%20%7Blazy_memory%3A.1f%7D%20MB%22)%0A%0A%20%20%20%20print(%22%5Cn2.%20Memory%20after%20computing%20full%20dataset%3A%22)%0A%20%20%20%20gc.collect()%0A%20%20%20%20start_memory%20%3D%20get_memory_usage()%0A%20%20%20%20_%20%3D%20adata_mem.compute()%0A%20%20%20%20end_memory%20%3D%20get_memory_usage()%0A%20%20%20%20print(f%22%20%20%20Eager%20loading%3A%20%7Bend_memory%3A.1f%7D%20MB%22)%0A%20%20%20%20print(f%22%20%20%20Memory%20increase%3A%20%7Bend_memory%20-%20start_memory%3A.1f%7D%20MB%22)%0A%0A%20%20%20%20print(%22%5Cn3.%20Memory%20after%20computing%20small%20slice%3A%22)%0A%20%20%20%20gc.collect()%0A%20%20%20%20slice_memory_before%20%3D%20get_memory_usage()%0A%20%20%20%20_%20%3D%20adata_mem%5B%3A100%2C%20%3A50%5D.compute()%0A%20%20%20%20slice_memory_after%20%3D%20get_memory_usage()%0A%20%20%20%20print(f%22%20%20%20Small%20slice%3A%20%7Bslice_memory_after%3A.1f%7D%20MB%22)%0A%20%20%20%20print(f%22%20%20%20Memory%20increase%3A%20%7Bslice_memory_after%20-%20slice_memory_before%3A.1f%7D%20MB%22)%0A%0A%20%20%20%20print(%0A%20%20%20%20%20%20%20%20f%22%5CnKey%20insight%3A%20Lazy%20loading%20uses%20%7Blazy_memory%3A.1f%7D%20MB%20vs%20eager%20loading%20%7Bend_memory%3A.1f%7D%20MB%22%0A%20%20%20%20)%0A%20%20%20%20print(f%22Memory%20savings%3A%20%7B((end_memory%20-%20lazy_memory)%20%2F%20end_memory%20*%20100)%3A.1f%7D%25%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%208.%20Advanced%20Slicing%20Patterns%0A%0A%20%20%20%20Let's%20explore%20more%20advanced%20slicing%20patterns%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(read_slaf%2C%20slaf_scanpy)%3A%0A%20%20%20%20%23%20Advanced%20slicing%20patterns%0A%20%20%20%20print(%22%F0%9F%94%AC%20Advanced%20Slicing%20Patterns%22)%0A%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%23%20Load%20data%20and%20add%20QC%20metrics%0A%20%20%20%20adata_advanced%20%3D%20read_slaf(%22..%2Fslaf-datasets%2Fpbmc3k_processed.slaf%22)%0A%20%20%20%20slaf_scanpy.pp.calculate_qc_metrics(adata_advanced%2C%20inplace%3DTrue)%0A%0A%20%20%20%20print(%221.%20Boolean%20indexing%20with%20QC%20metrics%3A%22)%0A%20%20%20%20high_quality_mask%20%3D%20adata_advanced.obs%5B%22n_genes_by_counts%22%5D%20%3E%201000%0A%20%20%20%20high_quality_cells%20%3D%20adata_advanced%5Bhigh_quality_mask%2C%20%3A%5D%0A%20%20%20%20print(f%22%20%20%20High%20quality%20cells%3A%20%7Bhigh_quality_cells.shape%7D%22)%0A%0A%20%20%20%20print(%22%5Cn2.%20Gene-based%20filtering%3A%22)%0A%20%20%20%20if%20(%0A%20%20%20%20%20%20%20%20hasattr(adata_advanced%2C%20%22var%22)%0A%20%20%20%20%20%20%20%20and%20adata_advanced.var%20is%20not%20None%0A%20%20%20%20%20%20%20%20and%20%22highly_variable%22%20in%20adata_advanced.var.columns%0A%20%20%20%20)%3A%0A%20%20%20%20%20%20%20%20hvg_mask%20%3D%20adata_advanced.var%5B%22highly_variable%22%5D%0A%20%20%20%20%20%20%20%20hvg_genes%20%3D%20adata_advanced%5B%3A%2C%20hvg_mask%5D%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Highly%20variable%20genes%3A%20%7Bhvg_genes.shape%7D%22)%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20print(%22%20%20%20(Highly%20variable%20genes%20not%20available%20yet)%22)%0A%0A%20%20%20%20print(%22%5Cn3.%20Combined%20cell%20and%20gene%20filtering%3A%22)%0A%20%20%20%20combined%20%3D%20adata_advanced%5Bhigh_quality_mask%2C%20%3A100%5D%0A%20%20%20%20print(f%22%20%20%20Combined%20filtering%3A%20%7Bcombined.shape%7D%22)%0A%0A%20%20%20%20print(%22%5Cn4.%20Expression-based%20filtering%3A%22)%0A%20%20%20%20%23%20Get%20cells%20with%20high%20total%20counts%0A%20%20%20%20high_counts_mask%20%3D%20adata_advanced.obs%5B%22total_counts%22%5D%20%3E%202000%0A%20%20%20%20high_counts_cells%20%3D%20adata_advanced%5Bhigh_counts_mask%2C%20%3A%5D%0A%20%20%20%20print(f%22%20%20%20High%20count%20cells%3A%20%7Bhigh_counts_cells.shape%7D%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%209.%20Lazy%20vs%20Eager%20Performance%20Comparison%0A%0A%20%20%20%20Let's%20compare%20the%20performance%20of%20lazy%20vs%20eager%20approaches%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(adata%2C%20slaf_scanpy%2C%20time)%3A%0A%20%20%20%20%23%20Performance%20comparison%0A%20%20%20%20def%20compare_lazy_vs_eager_performance(adata)%3A%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A1%20Lazy%20vs%20Eager%20Performance%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22%20*%2035)%0A%0A%20%20%20%20%20%20%20%20%23%20Test%20scenario%3A%20Apply%20transformations%20and%20slice%0A%20%20%20%20%20%20%20%20print(%22Scenario%3A%20normalize_total%20%E2%86%92%20log1p%20%E2%86%92%20slice%5B%3A100%2C%20%3A50%5D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Lazy%20approach%0A%20%20%20%20%20%20%20%20print(%22%5Cn1.%20Lazy%20approach%3A%22)%0A%20%20%20%20%20%20%20%20adata_lazy%20%3D%20adata%0A%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20lazy_pipeline%20%3D%20slaf_scanpy.pp.normalize_total(%0A%20%20%20%20%20%20%20%20%20%20%20%20adata_lazy%2C%20target_sum%3D1e4%2C%20inplace%3DFalse%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20lazy_pipeline%20%3D%20slaf_scanpy.pp.log1p(lazy_pipeline%2C%20inplace%3DFalse)%0A%20%20%20%20%20%20%20%20lazy_slice%20%3D%20lazy_pipeline%5B%3A100%2C%20%3A50%5D%0A%20%20%20%20%20%20%20%20lazy_build_time%20%3D%20time.time()%20-%20start_time%0A%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20%23%20Use%20.X.compute()%20to%20avoid%20the%20metadata%20mismatch%20issue%0A%20%20%20%20%20%20%20%20_%20%3D%20lazy_slice.X.compute()%0A%20%20%20%20%20%20%20%20lazy_compute_time%20%3D%20time.time()%20-%20start_time%0A%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Build%20time%3A%20%7Blazy_build_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Compute%20time%3A%20%7Blazy_compute_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Total%20time%3A%20%7Blazy_build_time%20%2B%20lazy_compute_time%3A.4f%7Ds%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Eager%20approach%20(simulated)%0A%20%20%20%20%20%20%20%20print(%22%5Cn2.%20Eager%20approach%20(simulated)%3A%22)%0A%0A%20%20%20%20%20%20%20%20start_time%20%3D%20time.time()%0A%20%20%20%20%20%20%20%20_%20%3D%20adata.compute()%0A%20%20%20%20%20%20%20%20eager_load_time%20%3D%20time.time()%20-%20start_time%0A%0A%20%20%20%20%20%20%20%20%23%20Simulate%20eager%20transformations%20(this%20would%20be%20done%20in%20memory)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%20Load%20time%3A%20%7Beager_load_time%3A.4f%7Ds%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20Transformations%20would%20be%20done%20in%20memory%20(slower%20for%20large%20datasets)%22)%0A%0A%20%20%20%20%20%20%20%20print(%22%5Cn3.%20Key%20benefits%3A%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20Lazy%3A%20Build%20complex%20pipelines%20instantly%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20Lazy%3A%20Only%20compute%20what%20you%20need%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20Lazy%3A%20Memory%20efficient%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20-%20Lazy%3A%20SQL-level%20performance%20for%20operations%22)%0A%0A%20%20%20%20compare_lazy_vs_eager_performance(adata)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%2010.%20Best%20Practices%20and%20Tips%0A%0A%20%20%20%20Here%20are%20some%20best%20practices%20for%20using%20SLAF's%20lazy%20evaluation%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_()%3A%0A%20%20%20%20%23%20Best%20practices%0A%20%20%20%20print(%22%F0%9F%92%A1%20Best%20Practices%20and%20Tips%22)%0A%20%20%20%20print(%22%3D%22%20*%2030)%0A%0A%20%20%20%20print(%221.%20Pipeline%20Building%3A%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Build%20complete%20pipelines%20before%20computing%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Chain%20transformations%3A%20adata.normalize_total().log1p()%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Slice%20after%20transformations%20for%20efficiency%22)%0A%0A%20%20%20%20print(%22%5Cn2.%20Computation%20Control%3A%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20.compute()%20only%20when%20you%20need%20the%20data%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20.obs%20or%20.var%20for%20metadata%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20.X.compute()%20for%20expression%20matrix%20only%22)%0A%0A%20%20%20%20print(%22%5Cn3.%20Memory%20Management%3A%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Keep%20lazy%20objects%20for%20intermediate%20results%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Compute%20only%20final%20results%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20slicing%20to%20reduce%20memory%20usage%22)%0A%0A%20%20%20%20print(%22%5Cn4.%20Performance%20Optimization%3A%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Leverage%20SQL-level%20operations%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20boolean%20indexing%20for%20filtering%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Combine%20operations%20in%20single%20queries%20when%20possible%22)%0A%0A%20%20%20%20print(%22%5Cn5.%20Debugging%3A%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Check%20object%20types%3A%20type(adata)%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Check%20transformations%3A%20adata._transformations%22)%0A%20%20%20%20print(%22%20%20%20%E2%9C%85%20Use%20.info()%20for%20dataset%20overview%22)%0A%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%23%23%20Summary%0A%0A%20%20%20%20**What%20you've%20learned%20about%20SLAF's%20lazy%20processing%3A**%0A%0A%20%20%20%201.%20**Lazy%20Objects**%3A%20LazyAnnData%20and%20LazyExpressionMatrix%20store%20operations%2C%20not%20data%0A%20%20%20%202.%20**Explicit%20Control**%3A%20Use%20.compute()%20methods%20to%20control%20when%20data%20is%20processed%0A%20%20%20%203.%20**Slicing%20Patterns**%3A%20Multiple%20slicing%20patterns%2C%20all%20lazy%20and%20composable%0A%20%20%20%204.%20**Transformations**%3A%20Lazy%20transformations%20that%20are%20preserved%20through%20operations%0A%20%20%20%205.%20**Performance**%3A%20Build%20complex%20pipelines%20instantly%2C%20compute%20only%20when%20needed%0A%20%20%20%206.%20**Memory%20Efficiency**%3A%20Significant%20memory%20savings%20compared%20to%20eager%20loading%0A%20%20%20%207.%20**Best%20Practices**%3A%20Guidelines%20for%20optimal%20lazy%20evaluation%20usage%0A%0A%20%20%20%20**Next%20Steps%3A**%0A%20%20%20%20-%20**03-ml-training-pipeline.py**%3A%20Complete%20ML%20training%20workflows%20with%20tokenizers%20and%20dataloaders%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20app.run()%0A
</marimo-code>

<marimo-code-hash hidden="">fd028d92f5a9a2d27f3abcf7257a49672f335e10727bf04e3d88c47dfd3d9ae2</marimo-code-hash>
</body>
</html>
